ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw()
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
labs(fill = "k Value")
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
labs(fill = "k Value")
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
guides(fill=guide_legend(title="New Legend Title"))
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
scale_fill_discrete(name = "New Legend Title")
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
labs(fill='NEW LEGEND TITLE')
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
scale_fill_manual("legend_title",values=c("orange","red"))
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
labs(colour="NEW LEGEND TITLE")
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
labs(colour="K value")
ggplot(cssemDatAggre, aes(x = cssemPolyk1.Category, y = mean)) +
geom_line(colour ="blue") +
geom_point(colour="blue") +
geom_ribbon(aes(ymin = lower, ymax = upper), fill= "blue", alpha = 0.2) +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
theme_bw()
### aggregate many to one ------------
cssemDatWide <- CSSEMPolynomial(40, convTableSub, K)
cssemDat <- cssemDatWide # test
k <- 13 # test, accepted maximum + 1
cssemDat <- cssemDat[,c(3,5:(5+k-2))]
cssemDatAggre <- as.data.frame(apply(cssemDat[,c(-1)], 2, function(x) aggregate(x, by=list(Category=cssemDat$roundedSS), FUN=mean)))
cssemDatAggre <- cssemDatAggre[,c(1, seq(2, 24, 2))]
### range and confidence interval  with k from 1 to maximum accepted ----------
cssemDatAggre$max <- apply(cssemDatAggre[,c(-1)], 1, max)
cssemDatAggre$min <- apply(cssemDatAggre[,c(-1)], 1, min)
cssemDatAggre$mean <- apply(cssemDatAggre[,c(-1)], 1, mean)
cssemDatAggre$median <- apply(cssemDatAggre[,c(-1)], 1, median)
cssemDatAggre$sd <- apply(cssemDatAggre[,c(-1)], 1, sd)
# 95% confidence interval
cssemDatAggre <- within(cssemDatAggre, {
lower = mean - 1.96 * sd
upper = mean + 1.96 * sd
})
### plot confidence interval
# k = 1 to maximum accepted
ggplot(cssemDatAggre, aes(x = cssemPolyk1.Category, y = mean)) +
geom_line(colour ="blue") +
geom_point(colour="blue") +
geom_ribbon(aes(ymin = lower, ymax = upper), fill= "blue", alpha = 0.2) +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
theme_bw()
CSSEMPolynomial(40, convTableSub, K)
### aggregate many to one ------------
cssemDatWide <- CSSEMPolynomial(40, convTableSub, K)
cssemDat <- cssemDatWide # test
k <- 13 # test, accepted maximum + 1
cssemDat <- cssemDat[,c(3,5:(5+k-2))]
cssemDatAggre <- as.data.frame(apply(cssemDat[,c(-1)], 2, function(x) aggregate(x, by=list(Category=cssemDat$roundedSS), FUN=mean)))
cssemDatAggre <- cssemDatAggre[,c(1, seq(2, 24, 2))]
### range and confidence interval  with k from 3 to maximum accepted ---33333333333-------
cssemDatAggre$max <- apply(cssemDatAggre[,c(-1:-3)], 1, max)
cssemDatAggre$min <- apply(cssemDatAggre[,c(-1:-3)], 1, min)
cssemDatAggre$mean <- apply(cssemDatAggre[,c(-1:-3)], 1, mean)
cssemDatAggre$median <- apply(cssemDatAggre[,c(-1:-3)], 1, median)
cssemDatAggre$sd <- apply(cssemDatAggre[,c(-1:-3)], 1, sd)
# 95% confidence interval
cssemDatAggre <- within(cssemDatAggre, {
lower = mean - 1.96 * sd
upper = mean + 1.96 * sd
})
### plot confidence interval
# k = 1 to maximum accepted
ggplot(cssemDatAggre, aes(x = cssemPolyk1.Category, y = mean)) +
geom_line(colour ="blue") +
geom_point(colour="blue") +
geom_ribbon(aes(ymin = lower, ymax = upper), fill= "blue", alpha = 0.2) +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
theme_bw()
cssemDatLong <- reshape(cssemDatAggre,
direction = "long",
varying = list(names(cssemDatAggre)[2:k]),
v.names = "cssempoly",
idvar = c("cssemPolyk1.Category"),
timevar = "Kvalue",
times = 1:(k-1))
library(ggplot2)
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
labs(colour="K value")
### aggregate many to one ------------
cssemDatWide <- CSSEMPolynomial(40, convTableSub, K)
cssemDat <- cssemDatWide # test
k <- 13 # test, accepted maximum + 1
cssemDat <- cssemDat[,c(3,5:(5+k-2))]
cssemDatAggre <- as.data.frame(apply(cssemDat[,c(-1)], 2, function(x) aggregate(x, by=list(Category=cssemDat$roundedSS), FUN=mean)))
cssemDatAggre <- cssemDatAggre[,c(1, seq(2, 24, 2))]
### range and confidence interval  with k from 1 to maximum accepted ----------
cssemDatAggre$max <- apply(cssemDatAggre[,c(-1)], 1, max)
cssemDatAggre$min <- apply(cssemDatAggre[,c(-1)], 1, min)
cssemDatAggre$mean <- apply(cssemDatAggre[,c(-1)], 1, mean)
cssemDatAggre$median <- apply(cssemDatAggre[,c(-1)], 1, median)
cssemDatAggre$sd <- apply(cssemDatAggre[,c(-1)], 1, sd)
# 95% confidence interval
cssemDatAggre <- within(cssemDatAggre, {
lower = mean - 1.96 * sd
upper = mean + 1.96 * sd
})
### plot confidence interval
# k = 1 to maximum accepted
ggplot(cssemDatAggre, aes(x = cssemPolyk1.Category, y = mean)) +
geom_line(colour ="blue") +
geom_point(colour="blue") +
geom_ribbon(aes(ymin = lower, ymax = upper), fill= "blue", alpha = 0.2) +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
theme_bw()
cssemDatWide <- CSSEMPolynomial(40, convTableSub, K)
cssemDat <- cssemDatWide # test
k <- 13 # test, accepted maximum + 1
cssemDat <- cssemDat[,c(3,5:(5+k-2))]
cssemDatAggre <- as.data.frame(apply(cssemDat[,c(-1)], 2, function(x) aggregate(x, by=list(Category=cssemDat$roundedSS), FUN=mean)))
cssemDatAggre <- cssemDatAggre[,c(1, seq(2, 24, 2))]
### range and confidence interval  with k from 3 to maximum accepted ---33333333333-------
cssemDatAggre$max <- apply(cssemDatAggre[,c(-1:-3)], 1, max)
cssemDatAggre$min <- apply(cssemDatAggre[,c(-1:-3)], 1, min)
cssemDatAggre$mean <- apply(cssemDatAggre[,c(-1:-3)], 1, mean)
cssemDatAggre$median <- apply(cssemDatAggre[,c(-1:-3)], 1, median)
cssemDatAggre$sd <- apply(cssemDatAggre[,c(-1:-3)], 1, sd)
# 95% confidence interval
cssemDatAggre <- within(cssemDatAggre, {
lower = mean - 1.96 * sd
upper = mean + 1.96 * sd
})
### plot confidence interval
# k = 1 to maximum accepted
ggplot(cssemDatAggre, aes(x = cssemPolyk1.Category, y = mean)) +
geom_line(colour ="blue") +
geom_point(colour="blue") +
geom_ribbon(aes(ymin = lower, ymax = upper), fill= "blue", alpha = 0.2) +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
theme_bw()
source("R/CSEMLord.R")
source("R/PolynomialMethod.R")
# Note: 1. cssemDat should include rawScore, roundedSS, and Lordcsem
#       2. conversion table should include raw score and rounded scale score
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
K <- 15
CSSEMPolynomial <- function(numOfItem, convTable, K){
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
PolynomialMethod(cssemDat, K)
}
CSSEMPolynomial(numOfItem, convTableSub, K)
itemPara <- read.table("TestData/ItemParaFormX.txt")
itemPara <- read.table("TestData/ItemParaFormX.txt")
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("theta", "infoSum")
library(statmod)
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("theta", "infoSum")
View(itemParaInfo)
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
View(convTableSub)
View(convTable)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
View(convTable)
View(convTableSub)
# read item parameter
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
quadPoints$nodes <- convTableSub$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTableSub$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
View(itemParaInfo)
names(itemParaInfo) <- c("theta", "infoSum")
View(convTableSub)
View(convTableSub)
# merge data
itemParaInfo <- merge(itemParaInfo, convTableSub, by = "thetaScore")
View(itemParaInfo)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTableSub, by = "thetaScore")
View(itemParaInfo)
itemParaInfo$csemMLE <- sqrt(1/itemParaInfo$infoSum)
View(itemParaInfo)
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore","infoSum",'csemLord", "roundedSS")
}
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore","infoSum","csemLord", "roundedSS")
1
)
)
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "csemLord", "roundedSS")
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
source("R/PolynomialMethod.R")
PolynomialMethod(itemParaInfo, 20)
# read item parameter
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMMLEPoly <- function(itemPara, convTable){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemMLE <- sqrt(1/itemParaInfo$infoSum)
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, 20)
}
CSSEMMLEPoly(itemPara, convTableSub)
### CSSEM IRT EAP Polynomial Method
### CSSEM IRT MLE Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMMLEPoly <- function(itemPara, convTable){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemEAP <- sqrt(1/(itemParaInfo$infoSum+1))
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, 20)
}
CSSEMMLEPoly(itemPara, convTableSub)
### CSSEM IRT MLE Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMMLEPoly <- function(itemPara, convTable){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemMLE <- sqrt(1/itemParaInfo$infoSum)
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, 20)
}
CSSEMMLEPoly(itemPara, convTableSub)
### select column without negative values?
# read raw data
rawData <- read.table("TestData/RawDataFormX.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
View(rawFreq)
names(rawFreq) <- c("rawScore", "freq")
View(convTableSub)
View(convTable)
CSSEMMLEPoly(itemPara, convTableSub)
cssemMLEPolyDat <- CSSEMMLEPoly(itemPara, convTableSub)
cssemMLEPolyDat
cssemMLEPolyDat$rawScore <- c(0:40)
View(cssemMLEPolyDat)
# read raw data
rawData <- read.table("TestData/RawDataFormX.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
sum(cssemMLEPolyDat$wt)
MLE <- 1 - sum(cssemMLEPolyDat$cssemPolyk4^2 * cssemMLEPolyDat$wt)/wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
library(SDMTools)
MLE <- 1 - sum(cssemMLEPolyDat$cssemPolyk4^2 * cssemMLEPolyDat$wt)/wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
MLE
library(SDMTools)
MLE <- 1 - sum(cssemMLEPolyDat$cssemPolyk4^2 * cssemMLEPolyDat$wt)/wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
MLE
### CSSEM IRT EAP Polynomial Method
### CSSEM IRT MLE Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMEAPPoly <- function(itemPara, convTable){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemEAP <- sqrt(1/(itemParaInfo$infoSum+1))
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, 20)
}
CSSEMEAPPoly(itemPara, convTableSub)
### select column without negative values?
### reliability
# rounded scale score reliability; k = 4
cssemEAPPolyDat <- CSSEMEAPPoly(itemPara, convTableSub)
cssemEAPPolyDat$rawScore <- c(0:40)
### raw score frequency
# read raw data
rawData <- read.table("TestData/RawDataFormX.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
cssemEAPPolyDat <- merge(cssemEAPPolyDat, rawFreq, by = "rawScore")
# weight
cssemEAPPolyDat$wt <- cssemEAPPolyDat$freq / sum(cssemEAPPolyDat$freq)
library(SDMTools)
EAP <- 1 - sum(cssemEAPPolyDat$cssemPolyk4^2 * cssemEAPPolyDat$wt)/wt.var(cssemEAPPolyDat$roundedSS, cssemEAPPolyDat$wt)
EAP
