cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
library(SDMTools)
# select k = 4
MLE <- 1 - sum(cssemMLEPolyDat$cssemPolyk4^2 * cssemMLEPolyDat$wt)/wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
MLE
### CSSEM IRT EAP Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMEAPPoly <- function(itemPara, convTable, K){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- NormalQuadraPoints(41)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemEAP <- sqrt(1/(itemParaInfo$infoSum+1))
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, K)
}
K <- 20
CSSEMEAPPoly(itemPara, convTableSub, K)
### select column without negative values?
### reliability
# rounded scale score reliability; k = 4
cssemEAPPolyDat <- CSSEMEAPPoly(itemPara, convTableSub, K)
cssemEAPPolyDat$rawScore <- c(0:40)
### raw score frequency
# read raw data
rawData <- read.table("TestData/RawDataFormX.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
cssemEAPPolyDat <- merge(cssemEAPPolyDat, rawFreq, by = "rawScore")
# weight
cssemEAPPolyDat$wt <- cssemEAPPolyDat$freq / sum(cssemEAPPolyDat$freq)
library(SDMTools)
# select k = 4
EAP <- 1 - sum(cssemEAPPolyDat$cssemPolyk4^2 * cssemEAPPolyDat$wt)/wt.var(cssemEAPPolyDat$roundedSS, cssemEAPPolyDat$wt)
EAP
cssemEAPPolyDat <- merge(cssemEAPPolyDat, rawFreq, by = "rawScore")
View(rawFreq)
View(cssemEAPPolyDat)
View(cssemEAPPolyDat)
### CSSEM IRT EAP Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMEAPPoly <- function(itemPara, convTable, K){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- NormalQuadraPoints(41)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemEAP <- sqrt(1/(itemParaInfo$infoSum+1))
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, K)
}
K <- 20
CSSEMEAPPoly(itemPara, convTableSub, K)
### select column without negative values?
### reliability
# rounded scale score reliability; k = 4
cssemEAPPolyDat <- CSSEMEAPPoly(itemPara, convTableSub, K)$`CSSEM Polynomial Method`
cssemEAPPolyDat$rawScore <- c(0:40)
### raw score frequency
# read raw data
rawData <- read.table("TestData/RawDataFormX.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
cssemEAPPolyDat <- merge(cssemEAPPolyDat, rawFreq, by = "rawScore")
# weight
cssemEAPPolyDat$wt <- cssemEAPPolyDat$freq / sum(cssemEAPPolyDat$freq)
library(SDMTools)
# select k = 4
EAP <- 1 - sum(cssemEAPPolyDat$cssemPolyk4^2 * cssemEAPPolyDat$wt)/wt.var(cssemEAPPolyDat$roundedSS, cssemEAPPolyDat$wt)
EAP
### CSSEM IRT EAP Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormY.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormY.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMEAPPoly <- function(itemPara, convTable, K){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- NormalQuadraPoints(41)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemEAP <- sqrt(1/(itemParaInfo$infoSum+1))
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, K)
}
K <- 20
CSSEMEAPPoly(itemPara, convTableSub, K)
### select column without negative values?
### reliability
# rounded scale score reliability; k = 4
cssemEAPPolyDat <- CSSEMEAPPoly(itemPara, convTableSub, K)$`CSSEM Polynomial Method`
cssemEAPPolyDat$rawScore <- c(0:40)
### raw score frequency
# read raw data
rawData <- read.table("TestData/RawDataFormY.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
cssemEAPPolyDat <- merge(cssemEAPPolyDat, rawFreq, by = "rawScore")
# weight
cssemEAPPolyDat$wt <- cssemEAPPolyDat$freq / sum(cssemEAPPolyDat$freq)
library(SDMTools)
# select k = 4
EAP <- 1 - sum(cssemEAPPolyDat$cssemPolyk4^2 * cssemEAPPolyDat$wt)/wt.var(cssemEAPPolyDat$roundedSS, cssemEAPPolyDat$wt)
EAP
### CSSEM Polynomial Method
source("R/CSEMLord.R")
source("R/PolynomialMethod.R")
# Note: 1. cssemDat should include rawScore, roundedSS, and Lordcsem
#       2. conversion table should include raw score and rounded scale score
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
# number of item
numOfItem <- 40
# highest degree of polynomial regression requested
K <- 15
CSSEMPolynomial <- function(numOfItem, convTable, K){
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
PolynomialMethod(cssemDat, K)
}
CSSEMPolynomial(numOfItem, convTableSub, K)
#### Plot --------------------------------------
library(ggplot2)
### aggregate many to one ------------
cssemDatWide <- CSSEMPolynomial(40, convTableSub, K)$"CSSEM Polynomial Method"
cssemDat <- cssemDatWide # test
k <- 13 # test, accepted maximum + 1
cssemDat <- cssemDat[,c(3,5:(5+k-2))]
cssemDatAggre <- as.data.frame(apply(cssemDat[,c(-1)], 2, function(x) aggregate(x, by=list(Category=cssemDat$roundedSS), FUN=mean)))
cssemDatAggre <- cssemDatAggre[,c(1, seq(2, 24, 2))]
### plot all ks ---------------------------------------------------
k <- 13 # The maximum accepted K
cssemDatLong <- reshape(cssemDatAggre,
direction = "long",
varying = list(names(cssemDatAggre)[2:k]),
v.names = "cssempoly",
idvar = c("cssemPolyk1.Category"),
timevar = "Kvalue",
times = 1:(k-1))
library(ggplot2)
ggplot(cssemDatLong, aes(x = cssemPolyk1.Category, y = cssempoly, color = factor(Kvalue))) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
geom_line() +
theme_bw() +
labs(colour="K value")
### range and confidence interval  with k from 1 to maximum accepted ----------
# moments
cssemDatAggre$max <- apply(cssemDatAggre[,c(-1)], 1, max)
cssemDatAggre$min <- apply(cssemDatAggre[,c(-1)], 1, min)
cssemDatAggre$mean <- apply(cssemDatAggre[,c(-1)], 1, mean)
cssemDatAggre$median <- apply(cssemDatAggre[,c(-1)], 1, median)
cssemDatAggre$sd <- apply(cssemDatAggre[,c(-1)], 1, sd)
# 95% confidence interval
cssemDatAggre_1 <- within(cssemDatAggre, {
lower = mean - 1.96 * sd
upper = mean + 1.96 * sd
})
### plot confidence interval --------------------------------------
# k = 1 to maximum accepted
ggplot(cssemDatAggre_1, aes(x = cssemPolyk1.Category, y = mean)) +
geom_line(colour ="blue") +
geom_point(colour="blue") +
geom_ribbon(aes(ymin = lower, ymax = upper), fill= "blue", alpha = 0.2) +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
theme_bw()
### range and confidence interval  with k from 3 to maximum accepted ---333333333333333333333333333333-------
# moments
cssemDatAggre$max <- apply(cssemDatAggre[,c(-1:-3)], 1, max)
cssemDatAggre$min <- apply(cssemDatAggre[,c(-1:-3)], 1, min)
cssemDatAggre$mean <- apply(cssemDatAggre[,c(-1:-3)], 1, mean)
cssemDatAggre$median <- apply(cssemDatAggre[,c(-1:-3)], 1, median)
cssemDatAggre$sd <- apply(cssemDatAggre[,c(-1:-3)], 1, sd)
# 95% confidence interval
cssemDatAggre <- within(cssemDatAggre, {
lower = mean - 1.96 * sd
upper = mean + 1.96 * sd
})
### plot confidence interval
# k = 1 to maximum accepted
ggplot(cssemDatAggre, aes(x = cssemPolyk1.Category, y = mean)) +
geom_line(colour ="blue") +
geom_point(colour="blue") +
geom_ribbon(aes(ymin = lower, ymax = upper), fill= "blue", alpha = 0.2) +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Polynomial Method") +
theme_bw()
#' @title CSSEM Kolen's Method
#'
#' @description
#' A function to calculate CSEM for Scale Scores in IRT using Kolen's method
#' True scale score
#'
#' @param numOfItem a numeric number indicating number of items
#' @param convTable a data frame or matrix containing conversion table of raw score to scale score
#'
#' @return a data frame containing CSSEM using Kolen's Method
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#'
#' @export
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
# read normal weights
normalWt <- read.table("TestData/NW_Kolen.txt")
library(statmod)
library(classify)
CSSEMKolen <- function(itemPara, convTable){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# number of quadrature
numOfQuad <- 40
# number of Items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- gauss.quad.prob(numOfQuad, dist = "normal", mu = 0, sigma = 1)
quadPoints$nodes <- normalWt$V1
quadPoints$weights <- normalWt$V2
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# reorder matrix by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
fxThetaTSS$SS <- rev(convTable$roundedSS)
# merge data
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA, nrow = numOfQuad, ncol = 1)
for (i in 1:numOfQuad){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41), numOfQuad + 1] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * quadPoints$weights))
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
# variance of scale score
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
}
CSSEMKolen(itemPara, convTable)
### Plot ------------------------------------------------------------------
cssemKolen <- as.data.frame(cssemKolen)
### true scale score ---------
cssemKolen$trueSS <- colSums(fxThetaTSS)[1:41]
names(cssemKolen) <- c("cssemKolen", "trueSS")
png("CSSEM_KolenIRT_A.png",  width = 799, height = 596)
library(ggplot2)
K <- ggplot(cssemKolen, aes(x = trueSS, y = cssemKolen)) +
geom_point(size = 2) +
scale_x_continuous(name = "True Scale Score", breaks  = seq(100,  130, 5)) +
scale_y_continuous(name = "CSSEM_Kolen IRT Method") +
theme_bw()
print(K)
dev.off()
write.csv(cssemKolen, "cssemKolen.csv")
### CSSEM Polynomial Method
source("R/CSEMLord.R")
source("R/PolynomialMethod.R")
# Note: 1. cssemDat should include rawScore, roundedSS, and Lordcsem
#       2. conversion table should include raw score and rounded scale score
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
# number of item
numOfItem <- 40
# highest degree of polynomial regression requested
K <- 15
CSSEMPolynomial <- function(numOfItem, convTable, K){
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
PolynomialMethod(cssemDat, K)
}
CSSEMPolynomial(numOfItem, convTableSub, K)
wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
### CSSEM IRT MLE Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormY.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormY.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
library(statmod)
CSSEMMLEPoly <- function(itemPara, convTable, K){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- NormalQuadraPoints(41)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemMLE <- sqrt(1/itemParaInfo$infoSum)
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, K)
}
K <- 20
CSSEMMLEPoly(itemPara, convTableSub, K) ### variable name should be changed
# names(CSSEMMLEPoly(itemPara, convTableSub, K)$`CSSEM Polynomial Method`)
### select column without negative values?
### reliability
# rounded scale score reliability; k = 4
cssemMLEPolyDat <- CSSEMMLEPoly(itemPara, convTableSub, K)$`CSSEM Polynomial Method`
cssemMLEPolyDat$rawScore <- c(0:40)
### raw score frequency
# read raw data
rawData <- read.table("TestData/RawDataFormY.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
library(SDMTools)
### CSSEM IRT MLE Polynomial Method
# read item parameter
itemPara <- read.table("TestData/ItemParaFormY.txt")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormY.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("thetaScore", "roundedSS")]
source("R/PolynomialMethod.R")
source("R/NormalQuadraPoints.R")
library(statmod)
CSSEMMLEPoly <- function(itemPara, convTable, K){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# weights and nodes
quadPoints <- NormalQuadraPoints(41)
# replace nodes with theta score in coversion table
quadPoints$nodes <- convTable$thetaScore
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("thetaScore", "infoSum")
# merge data
itemParaInfo <- merge(itemParaInfo, convTable, by = "thetaScore")
# transform inforamtion to csem
itemParaInfo$csemMLE <- sqrt(1/itemParaInfo$infoSum)
# change name to fit Polynomial Method function
names(itemParaInfo) <- c("rawScore", "infoSum", "roundedSS", "csemLord")
PolynomialMethod(itemParaInfo, K)
}
K <- 20
CSSEMMLEPoly(itemPara, convTableSub, K) ### variable name should be changed
# names(CSSEMMLEPoly(itemPara, convTableSub, K)$`CSSEM Polynomial Method`)
### select column without negative values?
### reliability
# rounded scale score reliability; k = 4
cssemMLEPolyDat <- CSSEMMLEPoly(itemPara, convTableSub, K)$`CSSEM Polynomial Method`
cssemMLEPolyDat$rawScore <- c(0:40)
### raw score frequency
# read raw data
rawData <- read.table("TestData/RawDataFormY.txt", header = F, sep = " ")
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
library(SDMTools)
# select k = 4
MLE <- 1 - sum(cssemMLEPolyDat$cssemPolyk3^2 * cssemMLEPolyDat$wt)/wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
MLE
wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
sum(cssemMLEPolyDat$cssemPolyk3^2 * cssemMLEPolyDat$wt)
# select k = 4
MLE <- 1 - sum(cssemMLEPolyDat$cssemPolyk3^2 * cssemMLEPolyDat$wt)/wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
MLE
# select k = 4
MLE <- 1 - sum(cssemMLEPolyDat$cssemPolyk4^2 * cssemMLEPolyDat$wt)/wt.var(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt)
MLE
