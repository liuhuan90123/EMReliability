# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
## fit model with k = 3 and get coefficients
m1 <- lm(roundedSS ~ 1 + rawScore + I(rawScore^2) + I(rawScore^3), cssemDat)
# summary(m1)
regCoef <- summary(m1)$coefficients[, 1]
# # first derivative
# f <- expression(8.573e-04 * x^3 -5.481e-02* x^2 + 1.578e+00 * x + 9.922e+01)
# D(f, "x")
# apply formula
cssemDat$fx <- 0.0008573 * (3 * cssemDat$rawScore^2) - 0.05481 * (2 * cssemDat$rawScore) + 1.578
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
cssemDat
summary(m1)$coefficients[, 1]
cssemDat$fx <- regCoef[4] * (3 * cssemDat$rawScore^2) + regCoef[3] * (2 * cssemDat$rawScore) + regCoef[2]
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
cssemDat
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
View(cssemDat)
m2 <- lm(roundedSS ~ poly(rawScore, 3, raw=TRUE))
m2 <- lm(roundedSS ~ poly(rawScore, 3, raw=TRUE), cssemDat)
m1 <- lm(roundedSS ~ 1 + rawScore + I(rawScore^2) + I(rawScore^3), cssemDat)
m2 <- lm(roundedSS ~ poly(rawScore, 3, raw=TRUE), cssemDat)
summary(m1)
summary(m2)
regCoef <- summary(modelK)$coefficients[, 1]
# fit model with k = 3 and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
k <- 3 # test
# fit model with k = 3 and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
3:3
cssemDat
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
# calculate transformation coefficients fx: from k to 1
cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore) + regCoef[(k-1)]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
cssemDat
names(cssemDat$cssemPoly) <- paste("cssemPolyk", k, sep = "")
cssemDat
paste("cssemPolyk", k, sep = "")
names(cssemDat$cssemPoly) <- paste("cssemPolyk", k, sep = "")
View(cssemDat)
colnames(cssemDat)
colnames(cssemDat)["cssemPoly"]
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
cssemDat
k <- 1 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
k <- 2 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
k <- 2 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1
cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore) + regCoef[(k-1)]
cssemDat$fx
cssemDat$fx <- 0
regCoef
### CSSEM Polynomial Method
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
CSSEMPolynomial <- function(numOfItem, convTable){
# numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
## fit model with k = 3 and get coefficients
m1 <- lm(roundedSS ~ 1 + rawScore + I(rawScore^2) + I(rawScore^3), cssemDat)
summary(m1)
# first derivative
f <- expression(8.573e-04 * x^3 -5.481e-02* x^2 + 1.578e+00 * x + 9.922e+01)
D(f, "x")
# apply formula
cssemDat$fx <- 0.0008573 * (3 * cssemDat$rawScore^2) - 0.05481 * (2 * cssemDat$rawScore) + 1.578
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
# return polynomial cssem based on Lord csem
return(cssemDat)
}
CSSEMPolynomial(40, convTableSub)
k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
View(cssemDat)
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
# numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
### CSEM Lord Mehtod
CSEMLord <- function(numOfItem){
# create matrix to store csem
csemDat <- matrix(nrow = numOfItem + 1, ncol = 1)
# for loop to calculate prob for each true score
for (i in 0:numOfItem){
# take raw score as true score
pi = i/numOfItem
# create data frame for raw score
binoDat <- as.data.frame(c(0:numOfItem))
names(binoDat) <- "raw"
# calculate prob using binomial
binoDat$prob <- choose(numOfItem, binoDat$raw) * (pi)^binoDat$raw * (1 - pi)^(numOfItem-binoDat$raw)
# calculate prob*X and prob*X^2
binoDat$xprob <- binoDat$raw * binoDat$prob
binoDat$x2prob <- binoDat$raw^2 * binoDat$prob
# calculate and store Lord's csem for this true score
seX <- sqrt(numOfItem/(numOfItem-1)) * sqrt(sum(binoDat$x2prob) - sum(binoDat$xprob)^2)
csemDat[i+1, 1] <- seX
}
# format csem data frame
csemDat <- as.data.frame(csemDat)
names(csemDat) <- c("csemLord")
csemDat$rawScore <- c(0:numOfItem)
# return Lord csem
return(csemDat)
}
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
cssemDat$fx <- 0
View(cssemDat)
while(k > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[k+1] * (k * cssemDat$rawScore^(k-1))
k <- k-1
}
cssemDat$fx <- cssemDat$fx + regCoef[1]
View(cssemDat)
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
cssemDat
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
cssemDat$fx <- 0
cssemDat$fx <- cssemDat$fx +  regCoef[k+1] * (k * cssemDat$rawScore^(k-1))
regCoef[k+1]
k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
while(k > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[k+1] * (k * cssemDat$rawScore^(k-1))
k <- k-1
}
cssemDat$fx <- cssemDat$fx + regCoef[1]
View(cssemDat)
m1 <- lm(roundedSS ~ 1 + rawScore + I(rawScore^2) + I(rawScore^3), convTable)
summary(m1)
# first derivative
f <- expression(8.842e-04 * x^3 -5.671e-02* x^2 + 1.618e+00 * x + 9.899e+01)
D(f, "x")
# apply formula
convTable$fx <- 0.0008842 * (3 * convTable$rawScore^2) - 0.05671 * (2 * convTable$rawScore) + 1.618
convTable$cssemPoly <- convTable$fx * convTable$csemLord
### CSEM Lord Method
library(SDMTools)
library(ggplot2)
# read raw data
rawData <- read.table("TestData/RawDataFormX.txt", header = F, sep = " ")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
### Lord and Binomial method ---------------------------------------------------------------
csemDat <- matrix(nrow = 41, ncol = 2)
for (i in 0:40){
pi = i/40
binoDat <- as.data.frame(c(0:40))
names(binoDat) <- "raw"
binoDat$prob <- choose(40, binoDat$raw) * (pi)^binoDat$raw * (1 - pi)^(40-binoDat$raw)
binoDat <- cbind(binoDat, convTableSub)
binoDat$xprob <- binoDat$rawScore * binoDat$prob
binoDat$x2prob <- binoDat$rawScore^2 * binoDat$prob
binoDat$ssprob <- binoDat$roundedSS * binoDat$prob
binoDat$ss2prob <- binoDat$roundedSS^2 * binoDat$prob
seX <- sqrt(40/(40-1)) * sqrt(sum(binoDat$x2prob) - sum(binoDat$xprob)^2)
seSS <- sqrt(40/(40-1)) * sqrt(sum(binoDat$ss2prob) - sum(binoDat$ssprob)^2)
csemDat[i+1, 1] <- seX
csemDat[i+1, 2] <- seSS
}
csemDat <- as.data.frame(csemDat)
names(csemDat) <- c("csemLord", "cssemBinomial")
csemDat$rawScore <- c(0:40)
### calculate reliability: ******* does not make sense ************------------------------------
# calculate raw score frequence
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
convTable <- merge(convTable, rawFreq, by = "rawScore")
convTable$wt <- convTable$freq / sum(convTable$freq)
convTable <- merge(convTable, csemDat, by = "rawScore")
# raw scale reliability using Lord CSEM
LordRel <- 1 - sum(convTable$csemLord^2 * convTable$wt)/wt.var(convTable$rawScore, convTable$wt)
# Scale score reliability using binomial method
SSRelCTTBinomial <- 1 - sum(convTable$cssemBinomial^2 * convTable$wt)/wt.var(convTable$roundedSS, convTable$wt)
### Plot function -----------------------------------------------------
# plot for Lord CSEM
png("CSEMLORD.png",  width = 799, height = 596)
CSEMLORDpng <- ggplot(convTable, aes(x = rawScore, y = csemLord)) +
geom_point() +
scale_x_continuous(name = "Raw Score", breaks  = seq(0, 40, 5)) +
scale_y_continuous(name = "CSEM Lord Method") +
theme_bw()
print(CSEMLORDpng)
dev.off()
## calculate average CSSEM: average of variance, not standard error
convTable$varBinomial <- convTable$cssemBinomial^2
convTableBinomial <- aggregate(convTable$varBinomial, by=list(Category=convTable$roundedSS), FUN=mean)
names(convTableBinomial) <- c("roundedSS", "varBinomialAvg")
convTableBinomial$cssemBinomialAvg <- sqrt(convTableBinomial$varBinomialAvg)
# plot for Binomial CSSEM
png("CSSEMCTTBinomial.png",  width = 799, height = 596)
CSSEMCTTBinomialpng <- ggplot(convTableBinomial, aes(x = roundedSS, y = cssemBinomialAvg)) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Binomial Method") +
theme_bw()
print(CSSEMCTTBinomialpng)
dev.off()
### Polynomial Method --------------------------------------------------------------------------------
## polynomial method
# write.csv(convTable, "convTable.csv")
m1 <- lm(roundedSS ~ 1 + rawScore + I(rawScore^2) + I(rawScore^3), convTable)
summary(m1)
# first derivative
f <- expression(8.842e-04 * x^3 -5.671e-02* x^2 + 1.618e+00 * x + 9.899e+01)
D(f, "x")
# apply formula
convTable$fx <- 0.0008842 * (3 * convTable$rawScore^2) - 0.05671 * (2 * convTable$rawScore) + 1.618
convTable$cssemPoly <- convTable$fx * convTable$csemLord
View(convTable)
k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
regCoef[1]
k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
while(k > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[k+1] * (k * cssemDat$rawScore^(k-1))
k <- k-1
}
cssemDat$fx <- cssemDat$fx + regCoef[k+1]
cssemDat
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
while(k > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[k+1] * (k * cssemDat$rawScore^(k-1))
k <- k-1
}
cssemDat$fx <- cssemDat$fx + regCoef[k+1]
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
cssemDat
View(convTable)
### CSEM Lord Method
library(SDMTools)
library(ggplot2)
# read raw data
rawData <- read.table("TestData/RawDataFormX.txt", header = F, sep = " ")
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
### Lord and Binomial method ---------------------------------------------------------------
csemDat <- matrix(nrow = 41, ncol = 2)
for (i in 0:40){
pi = i/40
binoDat <- as.data.frame(c(0:40))
names(binoDat) <- "raw"
binoDat$prob <- choose(40, binoDat$raw) * (pi)^binoDat$raw * (1 - pi)^(40-binoDat$raw)
binoDat <- cbind(binoDat, convTableSub)
binoDat$xprob <- binoDat$rawScore * binoDat$prob
binoDat$x2prob <- binoDat$rawScore^2 * binoDat$prob
binoDat$ssprob <- binoDat$roundedSS * binoDat$prob
binoDat$ss2prob <- binoDat$roundedSS^2 * binoDat$prob
seX <- sqrt(40/(40-1)) * sqrt(sum(binoDat$x2prob) - sum(binoDat$xprob)^2)
seSS <- sqrt(40/(40-1)) * sqrt(sum(binoDat$ss2prob) - sum(binoDat$ssprob)^2)
csemDat[i+1, 1] <- seX
csemDat[i+1, 2] <- seSS
}
csemDat <- as.data.frame(csemDat)
names(csemDat) <- c("csemLord", "cssemBinomial")
csemDat$rawScore <- c(0:40)
### calculate reliability: ******* does not make sense ************------------------------------
# calculate raw score frequence
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
convTable <- merge(convTable, rawFreq, by = "rawScore")
convTable$wt <- convTable$freq / sum(convTable$freq)
convTable <- merge(convTable, csemDat, by = "rawScore")
# raw scale reliability using Lord CSEM
LordRel <- 1 - sum(convTable$csemLord^2 * convTable$wt)/wt.var(convTable$rawScore, convTable$wt)
# Scale score reliability using binomial method
SSRelCTTBinomial <- 1 - sum(convTable$cssemBinomial^2 * convTable$wt)/wt.var(convTable$roundedSS, convTable$wt)
### Plot function -----------------------------------------------------
# plot for Lord CSEM
png("CSEMLORD.png",  width = 799, height = 596)
CSEMLORDpng <- ggplot(convTable, aes(x = rawScore, y = csemLord)) +
geom_point() +
scale_x_continuous(name = "Raw Score", breaks  = seq(0, 40, 5)) +
scale_y_continuous(name = "CSEM Lord Method") +
theme_bw()
print(CSEMLORDpng)
dev.off()
## calculate average CSSEM: average of variance, not standard error
convTable$varBinomial <- convTable$cssemBinomial^2
convTableBinomial <- aggregate(convTable$varBinomial, by=list(Category=convTable$roundedSS), FUN=mean)
names(convTableBinomial) <- c("roundedSS", "varBinomialAvg")
convTableBinomial$cssemBinomialAvg <- sqrt(convTableBinomial$varBinomialAvg)
# plot for Binomial CSSEM
png("CSSEMCTTBinomial.png",  width = 799, height = 596)
CSSEMCTTBinomialpng <- ggplot(convTableBinomial, aes(x = roundedSS, y = cssemBinomialAvg)) +
geom_point() +
scale_x_continuous(name = "Rounded Scale Score", breaks  = seq(100, 130, 5)) +
scale_y_continuous(name = "CSSEM Binomial Method") +
theme_bw()
print(CSSEMCTTBinomialpng)
dev.off()
### Polynomial Method --------------------------------------------------------------------------------
## polynomial method
# write.csv(convTable, "convTable.csv")
m1 <- lm(roundedSS ~ 1 + rawScore + I(rawScore^2) + I(rawScore^3), convTable)
summary(m1)
# first derivative
f <- expression(8.842e-04 * x^3 -5.671e-02* x^2 + 1.618e+00 * x + 9.899e+01)
D(f, "x")
# apply formula
convTable$fx <- 0.0008842 * (3 * convTable$rawScore^2) - 0.05671 * (2 * convTable$rawScore) + 1.618
convTable$cssemPoly <- convTable$fx * convTable$csemLord
View(convTable)
for (k in 1:10){
# k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1 k = 3
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
while(k > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[k+1] * (k * cssemDat$rawScore^(k-1))
k <- k-1
}
cssemDat$fx <- cssemDat$fx + regCoef[k+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
cssemDat
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
for (k in 2:10){
# k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1 k = 3
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
cssemDat
View(cssemDat)
for (k in 1:10){
# k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1 k = 3
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
cssemDat
# read conversion table from cvs file
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
convTableSub <- convTable[,c("rawScore", "roundedSS")]
numOfItem <- 40
csemLordDat <- CSEMLord(numOfItem)
cssemDat <- merge(csemLordDat, convTableSub, by = "rawScore")
for (k in 1:10){
# k <- 3 # test
# fit model with k and get coefficients
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
regCoef <- summary(modelK)$coefficients[, 1]
regCoef
# calculate transformation coefficients fx: from k to 1 k = 3
# cssemDat$fx <- regCoef[k+1] * (k * cssemDat$rawScore^(k-1)) + regCoef[k] * ((k-1) * cssemDat$rawScore^(k-2)) + regCoef[(k-1)]
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csemLord
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
cssemDat
cssemDatLong <- reshape(cssemDat,
direction = "long",
varying = list(names(cssemDat)[5:14]),
v.names = "cssem",
idvar = c("rawScore", "roundedSS"),
timevar = "Kvalue",
times = cssemPolyk1:cssemPolyk10)
