itemParaCSEM$SS <- round(itemParaCSEM$SS)
# calculate transformation coefficients fx: from 1 to K
itemParaCSEM$fx <- 0
i <- k
while(i > 1){
itemParaCSEM$fx <- itemParaCSEM$fx +  regCoef[i+1] * (i * itemParaCSEM$theta^(i-1))
i <- i-1
}
itemParaCSEM$fx <- itemParaCSEM$fx + regCoef[i+1]
# calculate cssem using polynomial method
itemParaCSEM$cssemPoly <- sqrt(itemParaCSEM$fx * (itemParaCSEM$csemMLE)^2)
# check negative values
negCount <- sum(itemParaCSEM$fx < 0)
if(negCount > 0){
message(paste("Negative transformation coefficient exists when k = ", k,
". The corresponding CSSEM will not be available.", sep = " "))
}else{
SSVar <- sum(itemParaCSEM$wt * (itemParaCSEM$SS - weighted.mean(itemParaCSEM$SS, itemParaCSEM$wt))^2)
errVar <- sum(itemParaCSEM$cssemPoly^2 * itemParaCSEM$wt)
relDat[k,1] <- 1 - errVar/SSVar
}
sd(itemParaCSEM$SS)
eahd(itemParaCSEM)
head(itemParaCSEM)
View(itemParaCSEM)
var(itemParaCSEM$SS)
mean(itemParaCSEM$cssemPoly)
1-0.7307463/14.79653
mean(itemParaCSEM$csemMLE)
mean(itemParaCSEM$csemMLE^2)
cssemPolynomial_A
cssemDat_MLE_A
sqrt(0.630908^2 * 3.7522059)
RelMLEPoly_A <- RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "MLE", rawData_A)
RelMLEPoly_A
RelEAPPoly_A <- RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "EAP", rawData_A)
RelEAPPoly_A
RelMLEPoly_B_new <- RelIRTPoly_new(itemPara_B, convTable_B_Poly, 20, "MLE")
RelMLEPoly_B_new
itemPara <- itemPara_A
convTable <- convTable_A_Poly
K <- 10
# theta and weights
theta <- NormalQuadraPoints(41)$nodes
# theta <- rnorm(10000)
# CSEM
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# weight
# itemParaCSEM$wt <- NormalQuadraPoints(41)$weights
rSquaredDat <- as.data.frame(matrix(nrow = K, ncol = 1))
relDat <- as.data.frame(matrix(nrow = K, ncol = 1))
k <- 4
# fit model with k
modelK <- lm(roundedSS ~ poly(theta, k, raw=TRUE), convTable)
# extract regression coefficients
regCoef <- summary(modelK)$coefficients[, 1]
# extract r square coefficient
rSquaredDat[k, 1]<- summary(modelK)$r.squared
# check whether regression coefficient of highest order is missing
if(is.na(regCoef[k+1])){
message(paste("The maximum k accepted is", k-1, sep = " "))
break
}
# (Intercept) poly(theta, k, raw = TRUE)1 poly(theta, k, raw = TRUE)2 poly(theta, k, raw = TRUE)3
# 118.263733790                 3.909028972                -0.360085771                -0.036053623
# poly(theta, k, raw = TRUE)4
# 0.009014156
# x <- -3.75
# 0.009014156 * x^4 + -0.036053623*x^3 +  -0.360085771* x^2 + 3.909028972*x + 118.263733790
# 4 * 0.009014156 * x^3 + 3* -0.036053623*x^2 +  2*-0.360085771* x + 3.909028972
# sqrt(0.630908^2 * 3.7522059)
# calculate SS: from 1 to K
itemParaCSEM$SS <- 0
i <- k
while(i > 0){
itemParaCSEM$SS <- itemParaCSEM$SS +  regCoef[i+1] * itemParaCSEM$theta^(i)
i <- i-1
}
itemParaCSEM$SS <- itemParaCSEM$SS + regCoef[i+1]
itemParaCSEM$SS <- round(itemParaCSEM$SS)
# calculate transformation coefficients fx: from 1 to K
itemParaCSEM$fx <- 0
i <- k
while(i > 1){
itemParaCSEM$fx <- itemParaCSEM$fx +  regCoef[i+1] * (i * itemParaCSEM$theta^(i-1))
i <- i-1
}
itemParaCSEM$fx <- itemParaCSEM$fx + regCoef[i+1]
# calculate cssem using polynomial method
itemParaCSEM$cssemPoly <- sqrt(itemParaCSEM$fx * (itemParaCSEM$csemMLE)^2)
itemParaCSEM
# weight
itemParaCSEM$wt <- NormalQuadraPoints(41)$weights
itemParaCSEM
write.xlsx(itemParaCSEM, "Poly_A_k4_rel.xlsx")
sum(itemParaCSEM$cssemPoly^2 * itemParaCSEM$wt)
sum(itemParaCSEM$wt * (itemParaCSEM$SS - weighted.mean(itemParaCSEM$SS, itemParaCSEM$wt))^2)
#' @title TestRelSSMIRT
#'
#' @description
#' A function to calculate test reliability of SS MIRT with 2PL model
#'
#' @param itemPara a data frame or matrix with parameters of sequence b, a1, a2,...,ai on the 1.702 metric
#' @param strat a vector containing number of items for each strat
#' @param cormat a correlation matrix for factors
#' @return test reliability of SS MIRT with 2PL model
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#' @export
TestRelSSMIRT <- function(itemPara, strat, cormat){
# num of items
numOfItem <- nrow(itemPara)
# num of quadratures
numOfQuad <- 15
# number of factors
numOfFactors <- length(strat)
# set nodes and weights
nodes <- seq(-5, 5, length.out = numOfQuad)
nodesM <- as.matrix(expand.grid(nodes,nodes,nodes))
weightsUnwtd <- dmvn(nodesM, c(0,0,0), cormat, log=FALSE)
nodesM <- as.data.frame(nodesM)
nodesM$weightsWtd <- weightsUnwtd / sum(weightsUnwtd)
# fxtheta distribution function
FxTheta <- function(itemPara){
# names item parameter
names(itemPara) <- c("b", "a")
# num of items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- NormalQuadraPoints(numOfQuad)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# order by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# define matrix of marginal distribution of theta
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1) # 41 num of quadratures, 41 num of raw sxores
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P),
nrow = numOfItem, ncol = 1, byrow = FALSE)
fxTheta[i, ] <- LordWingersky(probs)$probability
}
# reverse column sequence
fxTheta <- fxTheta[, c(ncol(fxTheta):1)]
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
fxTheta
}
# fxtheta distribution
fxTheta1 <- FxTheta(itemPara[1:strat[1],c("b", "a")])
fxTheta2 <- FxTheta(itemPara[(strat[1]+1):(strat[1]+strat[2]),c("b", "a")])
fxTheta3 <- FxTheta(itemPara[(strat[1]+strat[2]+1):(strat[1]+strat[2]+strat[3]),c("b", "a")])
names(fxTheta1) <- c(0:strat[1])
names(fxTheta2) <- c(0:strat[2])
names(fxTheta3) <- c(0:strat[3])
# for loop
tau <- c()
errvar <- c()
fyDistMat <- matrix(NA,numOfQuad^3,32)
n <- 0
for (k in 1:numOfQuad){
for (j in 1:numOfQuad){
for (i in 1:numOfQuad){
# index
n <- n+1
# fx distribution
fx1 <- t(fxTheta1[i,])
fx2 <- t(fxTheta2[j,])
fx3 <- t(fxTheta3[k,])
xSum <- expand.grid(rownames(fx1), rownames(fx2), rownames(fx3))
names(xSum) <- c("x1", "x2", "x3")
fxSum <- expand.grid(fx1, fx2, fx3)
names(fxSum) <- c("fx1", "fx2", "fx3")
fxThetaSum <- cbind(fxSum, xSum)
fxThetaSum$x1 <- as.numeric(as.character(fxThetaSum$x1))
fxThetaSum$x2 <- as.numeric(as.character(fxThetaSum$x2))
fxThetaSum$x3 <- as.numeric(as.character(fxThetaSum$x3))
# fy distribution
fxThetaSum$y <- fxThetaSum$x1 + fxThetaSum$x2 + fxThetaSum$x3
fxThetaSum$wty <- fxThetaSum$fx1 * fxThetaSum$fx2 * fxThetaSum$fx3
fy <- fxThetaSum[,c("y", "wty")]
fyDist <- aggregate(fy$wty, by=list(Category=fy$y), FUN=sum)
names(fyDist) <- c("y", "wts")
# weighted mean of Obs Y (true y) and variance of Obs Y
weightedMean <- sum(fyDist$y * fyDist$wts)/sum(fyDist$wts)
varianceY <- sum(fyDist$wts * (fyDist$y - weightedMean)^2)
# store results
tau[n] <- weightedMean
errvar[n] <- sum(fyDist$wts * (fyDist$y - weightedMean)^2)
fyDistMat[n,] <- t(fyDist$wts)
}
}
}
nodesM$tau <- tau
nodesM$errvar <- errvar
nodesM[,7:38] <- fyDistMat
# sum of error variance
varianceError <- sum(nodesM$weightsWtd*nodesM$errvar)
# sum of observed score variance
fyThetaWeighted <- apply(nodesM[,7:(7 + numOfItem)], 2, function(x) x * nodesM[,"weightsWtd"])
# sum weighted distribution
fyObsDist <- as.data.frame(matrix(colSums(fyThetaWeighted[,1:(1 + numOfItem)]), nrow = (1 + numOfItem), ncol = 1))
fyObsDist$y <- c(numOfItem:0)
names(fyObsDist) <- c("wts", "y")
# weighted mean of Obs Y
weightedMean <- sum(fyObsDist$y * fyObsDist$wts)/sum(fyObsDist$wts)
# variance of Obs Y
varianceObsY <- sum(fyObsDist$wts * (fyObsDist$y - weightedMean)^2)
# MIRT test reliability
TestRelSSMIRT <- 1 - varianceError/varianceObsY
return(TestRelSSMIRT)
}
itemPara_SS_A <- read.table("TestData/SpanishLit_prm_A_SS.txt")[,c(7:10)]
cormat_A <- matrix(c(1, 0.9067069, 0.6994119,
0.9067069, 1, 0.4891160,
0.6994119,0.4891160,1), nrow = 3)
strat <- c(13, 12, 6)
# item parameter transformation
names(itemPara_SS_A) <- c("b", "a1","a2","a3")
itemPara_SS_A$a <- c(itemPara_SS_A$a1[1:13], itemPara_SS_A$a2[14:25], itemPara_SS_A$a3[26:31])
itemPara_SS_A[,"b"] <- -itemPara_SS_A[,"b"]/itemPara_SS_A[,"a"]
itemPara_SS_A[,"a"] <- itemPara_SS_A[,"a"]/1.702
itemPara_SS_A$a1[1:13] <- itemPara_SS_A$a[1:13]
itemPara_SS_A$a2[14:25] <- itemPara_SS_A$a[14:25]
itemPara_SS_A$a3[26:31] <- itemPara_SS_A$a[26:31]
# form B
itemPara_SS_B <- read.table("TestData/SpanishLit_prm_B_SS.txt")[,c(7:10)]
cormat_B <- matrix(c(1, 0.97, 0.56,
0.97, 1, 0.48,
0.56,0.48,1), nrow = 3)
strat <- c(13, 12, 6)
# item parameter transformation
names(itemPara_SS_B) <- c("b", "a1","a2","a3")
itemPara_SS_B$a <- c(itemPara_SS_B$a1[1:13], itemPara_SS_B$a2[14:25], itemPara_SS_B$a3[26:31])
itemPara_SS_B[,"b"] <- -itemPara_SS_B[,"b"]/itemPara_SS_B[,"a"]
itemPara_SS_B[,"a"] <- itemPara_SS_B[,"a"]/1.702
itemPara_SS_B$a1[1:13] <- itemPara_SS_B$a[1:13]
itemPara_SS_B$a2[14:25] <- itemPara_SS_B$a[14:25]
itemPara_SS_B$a3[26:31] <- itemPara_SS_B$a[26:31]
TestRelSSMIRT(itemPara_SS_A, strat, cormat_A)
TestRelSSMIRT(itemPara_SS_B, strat, cormat_B)
# load packages
library(LaplacesDemon)
itemPara_SS_A <- read.table("TestData/SpanishLit_prm_A_SS.txt")[,c(7:10)]
cormat_A <- matrix(c(1, 0.9067069, 0.6994119,
0.9067069, 1, 0.4891160,
0.6994119,0.4891160,1), nrow = 3)
strat <- c(13, 12, 6)
# item parameter transformation
names(itemPara_SS_A) <- c("b", "a1","a2","a3")
itemPara_SS_A$a <- c(itemPara_SS_A$a1[1:13], itemPara_SS_A$a2[14:25], itemPara_SS_A$a3[26:31])
itemPara_SS_A[,"b"] <- -itemPara_SS_A[,"b"]/itemPara_SS_A[,"a"]
itemPara_SS_A[,"a"] <- itemPara_SS_A[,"a"]/1.702
itemPara_SS_A$a1[1:13] <- itemPara_SS_A$a[1:13]
itemPara_SS_A$a2[14:25] <- itemPara_SS_A$a[14:25]
itemPara_SS_A$a3[26:31] <- itemPara_SS_A$a[26:31]
# form B
itemPara_SS_B <- read.table("TestData/SpanishLit_prm_B_SS.txt")[,c(7:10)]
cormat_B <- matrix(c(1, 0.97, 0.56,
0.97, 1, 0.48,
0.56,0.48,1), nrow = 3)
strat <- c(13, 12, 6)
# item parameter transformation
names(itemPara_SS_B) <- c("b", "a1","a2","a3")
itemPara_SS_B$a <- c(itemPara_SS_B$a1[1:13], itemPara_SS_B$a2[14:25], itemPara_SS_B$a3[26:31])
itemPara_SS_B[,"b"] <- -itemPara_SS_B[,"b"]/itemPara_SS_B[,"a"]
itemPara_SS_B[,"a"] <- itemPara_SS_B[,"a"]/1.702
itemPara_SS_B$a1[1:13] <- itemPara_SS_B$a[1:13]
itemPara_SS_B$a2[14:25] <- itemPara_SS_B$a[14:25]
itemPara_SS_B$a3[26:31] <- itemPara_SS_B$a[26:31]
TestRelSSMIRT(itemPara_SS_A, strat, cormat_A)
TestRelSSMIRT(itemPara_SS_B, strat, cormat_B)
profvis({
TestRelSSMIRT(itemPara_SS_A, strat, cormat_A)
})
library(profvis)
library(LaplacesDemon)
TestRelSSMIRT(itemPara_SS_A, strat, cormat_A)
profvis({
TestRelSSMIRT(itemPara_SS_A, strat, cormat_A)
})
itemPara_SS_A
cormat <- cormat_A
itemPara <- itemPara_SS_A
itemPara
cormat
library(LaplacesDemon)
library(profvis)
# Form A
itemPara_SS_A <- read.table("TestData/SpanishLit_prm_A_SS.txt")[,c(7:10)]
cormat_A <- matrix(c(1, 0.9067069, 0.6994119,
0.9067069, 1, 0.4891160,
0.6994119,0.4891160,1), nrow = 3)
strat <- c(13, 12, 6)
# item parameter transformation
names(itemPara_SS_A) <- c("b", "a1","a2","a3")
itemPara_SS_A$a <- c(itemPara_SS_A$a1[1:13], itemPara_SS_A$a2[14:25], itemPara_SS_A$a3[26:31])
itemPara_SS_A[,"b"] <- -itemPara_SS_A[,"b"]/itemPara_SS_A[,"a"]
itemPara_SS_A[,"a"] <- itemPara_SS_A[,"a"]/1.702
itemPara_SS_A$a1[1:13] <- itemPara_SS_A$a[1:13]
itemPara_SS_A$a2[14:25] <- itemPara_SS_A$a[14:25]
itemPara_SS_A$a3[26:31] <- itemPara_SS_A$a[26:31]
itemPara <- itemPara_SS_A
cormat <- cormat_A
library(LaplacesDemon)
library(profvis)
# Form A
itemPara_SS_A <- read.table("TestData/SpanishLit_prm_A_SS.txt")[,c(7:10)]
cormat_A <- matrix(c(1, 0.9067069, 0.6994119,
0.9067069, 1, 0.4891160,
0.6994119,0.4891160,1), nrow = 3)
strat <- c(13, 12, 6)
# item parameter transformation
names(itemPara_SS_A) <- c("b", "a1","a2","a3")
itemPara_SS_A$a <- c(itemPara_SS_A$a1[1:13], itemPara_SS_A$a2[14:25], itemPara_SS_A$a3[26:31])
itemPara_SS_A[,"b"] <- -itemPara_SS_A[,"b"]/itemPara_SS_A[,"a"]
itemPara_SS_A[,"a"] <- itemPara_SS_A[,"a"]/1.702
itemPara_SS_A$a1[1:13] <- itemPara_SS_A$a[1:13]
itemPara_SS_A$a2[14:25] <- itemPara_SS_A$a[14:25]
itemPara_SS_A$a3[26:31] <- itemPara_SS_A$a[26:31]
itemPara <- itemPara_SS_A
cormat <- cormat_A
TestRelSSMIRT <- function(itemPara, strat, cormat){
# num of items
numOfItem <- nrow(itemPara)
# num of quadratures
numOfQuad <- 41
# number of factors
numOfFactors <- length(strat)
# set nodes and weights
nodes <- seq(-5, 5, length.out = numOfQuad)
nodesM <- as.matrix(expand.grid(nodes,nodes,nodes))
weightsUnwtd <- dmvn(nodesM, c(0,0,0), cormat, log=FALSE)
nodesM <- as.data.frame(nodesM)
nodesM$weightsWtd <- weightsUnwtd / sum(weightsUnwtd)
# fxtheta distribution function
FxTheta <- function(itemPara){
# names item parameter
names(itemPara) <- c("b", "a")
# num of items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- NormalQuadraPoints(numOfQuad)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# order by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# define matrix of marginal distribution of theta
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1) # 41 num of quadratures, 41 num of raw sxores
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P),
nrow = numOfItem, ncol = 1, byrow = FALSE)
fxTheta[i, ] <- LordWingersky(probs)$probability
}
# reverse column sequence
fxTheta <- fxTheta[, c(ncol(fxTheta):1)]
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
fxTheta
}
# fxtheta distribution
fxTheta1 <- FxTheta(itemPara[1:strat[1],c("b", "a")])
fxTheta2 <- FxTheta(itemPara[(strat[1]+1):(strat[1]+strat[2]),c("b", "a")])
fxTheta3 <- FxTheta(itemPara[(strat[1]+strat[2]+1):(strat[1]+strat[2]+strat[3]),c("b", "a")])
names(fxTheta1) <- c(0:strat[1])
names(fxTheta2) <- c(0:strat[2])
names(fxTheta3) <- c(0:strat[3])
# for loop
tau <- c()
errvar <- c()
fyDistMat <- matrix(NA,numOfQuad^3,32)
n <- 0
for (k in 1:numOfQuad){
for (j in 1:numOfQuad){
for (i in 1:numOfQuad){
# index
n <- n+1
# fx distribution
fx1 <- t(fxTheta1[i,])
fx2 <- t(fxTheta2[j,])
fx3 <- t(fxTheta3[k,])
xSum <- expand.grid(rownames(fx1), rownames(fx2), rownames(fx3))
names(xSum) <- c("x1", "x2", "x3")
fxSum <- expand.grid(fx1, fx2, fx3)
names(fxSum) <- c("fx1", "fx2", "fx3")
fxThetaSum <- cbind(fxSum, xSum)
fxThetaSum$x1 <- as.numeric(as.character(fxThetaSum$x1))
fxThetaSum$x2 <- as.numeric(as.character(fxThetaSum$x2))
fxThetaSum$x3 <- as.numeric(as.character(fxThetaSum$x3))
# fy distribution
fxThetaSum$y <- fxThetaSum$x1 + fxThetaSum$x2 + fxThetaSum$x3
fxThetaSum$wty <- fxThetaSum$fx1 * fxThetaSum$fx2 * fxThetaSum$fx3
fy <- fxThetaSum[,c("y", "wty")]
fyDist <- aggregate(fy$wty, by=list(Category=fy$y), FUN=sum)
names(fyDist) <- c("y", "wts")
# weighted mean of Obs Y (true y) and variance of Obs Y
weightedMean <- sum(fyDist$y * fyDist$wts)/sum(fyDist$wts)
varianceY <- sum(fyDist$wts * (fyDist$y - weightedMean)^2)
# store results
tau[n] <- weightedMean
errvar[n] <- sum(fyDist$wts * (fyDist$y - weightedMean)^2)
fyDistMat[n,] <- t(fyDist$wts)
}
}
}
nodesM$tau <- tau
nodesM$errvar <- errvar
nodesM[,7:38] <- fyDistMat
# sum of error variance
varianceError <- sum(nodesM$weightsWtd*nodesM$errvar)
# sum of observed score variance
fyThetaWeighted <- apply(nodesM[,7:(7 + numOfItem)], 2, function(x) x * nodesM[,"weightsWtd"])
# sum weighted distribution
fyObsDist <- as.data.frame(matrix(colSums(fyThetaWeighted[,1:(1 + numOfItem)]), nrow = (1 + numOfItem), ncol = 1))
fyObsDist$y <- c(numOfItem:0)
names(fyObsDist) <- c("wts", "y")
# weighted mean of Obs Y
weightedMean <- sum(fyObsDist$y * fyObsDist$wts)/sum(fyObsDist$wts)
# variance of Obs Y
varianceObsY <- sum(fyObsDist$wts * (fyObsDist$y - weightedMean)^2)
# MIRT test reliability
TestRelSSMIRT <- 1 - varianceError/varianceObsY
return(TestRelSSMIRT)
}
profvis({
TestRelSSMIRT(itemPara_SS_A, strat, cormat_A)
})
#' @title normal quadrature points and normalized weights
#'
#' @description
#' A function to generate quadrature points and normalized weights
#'
#' @param n number of quadrature points evenly distributed from -5 to +5
#'
#' @return a list containing nodes and normalized weights
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#'
#' @export
NormalQuadraPoints <- function(n){
# set nodes ranging from -5 to 5
nodes <- seq(-5, 5, length.out = n)
# unnormalized weights
weightsUnwtd <- sapply(nodes, FUN = function(x) dnorm(x))
# normalized weightes
weightsWtd <- weightsUnwtd / sum(weightsUnwtd)
# return nodes and normalized weights
return(list("nodes" = nodes, "weights" = weightsWtd))
}
profvis({
TestRelSSMIRT(itemPara_SS_A, strat, cormat_A)
})
#' @title Lord Wingersky recursive formula
#'
#' @description
#' A function to calculate raw score distribution conditional on quadrature points
#'
#' @param probs probabilities that a theta value can correctly answer each item
#'
#' @return probability of raw score distribution for the specfic theta
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#'
#' @export
LordWingersky <- function(probs){
# check p matrix
if(!is.matrix(probs))
probs <- as.matrix(probs)
# number of items
numOfItems <- dim(probs)[1]
# matrix for storing final probs
obsX <- array(0, c(numOfItems+1, numOfItems))
qprobs <- 1 - probs
l <- 1
obsX[1,l] <- qprobs[1,]
obsX[2,l] <- probs[1,]
obsXR <- obsX[1,l]
obsXR2 <- obsX[2,l]
for(i in 2:numOfItems){
for(r in 1:(i + 1)){
if(r == 1)
obsXR <- obsXR * qprobs[i,]
if(r > 1 && r < (i + 1))
obsX[r, l+1] <- obsX[r, l] * qprobs[i, ] + obsX[r-1, l] * probs[i, ]
if(r == (i + 1)){
obsXR2 <- obsXR2 * probs[i,]
obsX[r, l+1] <- obsXR2
}
}
obsX[1, l+1] <- obsXR
l <- l + 1
}
return(list("ObservedScore" = 0:numOfItems, "probability" = obsX[ ,numOfItems]))
}
q()
