theta <- NormalQuadraPoints(41)$nodes
# CSEM MLE
itemParaCSEM <- CSEMIRT(theta, itemPara, "MLE")
View(itemParaCSEM)
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaInfo, convTable, by = "theta")
itemParaCSEM
theta <- NormalQuadraPoints(41)$nodes
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable, by = "theta")
convTable
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_A, by = "theta")
itemParaCSEM
theta <- convTable_A$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_A, by = "theta")
itemParaCSEM
theta <- convTable_A$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_A_sub, by = "theta")
View(convTable_A_sub)
convTable_A_Poly <- convTable_A[,c("theta", "roundedSS")]
convTable_B_Poly <- convTable_B[,c("theta", "roundedSS")]
theta <- convTable_A_Poly$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_A_Poly, by = "theta")
itemParaCSEM
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
PolynomialMethod(itemParaCSEM, 20)
itemParaCSEM
# csem Lord
csemLordDat <- CSEMLord(numOfItem)
# merge with converstion table
cssemDat <- merge(csemLordDat, convTable, by = "rawScore")
cssemDat
# apply polynomial method
cssemPolynomial <- PolynomialMethod(cssemDat, K)
# csem Lord
csemLordDat <- CSEMLord(numOfItem)
# merge with converstion table
cssemDat <- merge(csemLordDat, convTable, by = "rawScore")
# change variable name
names(cssemDat)[names(cssemDat) == 'csemLord'] <- 'csem'
# apply polynomial method
cssemPolynomial <- PolynomialMethod(cssemDat, K)
cssemDat
# create data frame to store r square
rSquaredDat <- as.data.frame(matrix(nrow = K, ncol = 1))
# for loop to iterate different k
for (k in 1:K){
# fit model with k
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
# extract regression coefficients
regCoef <- summary(modelK)$coefficients[, 1]
# extract r square coefficient
rSquaredDat[k, 1]<- summary(modelK)$r.squared
# check whether regression coefficient of highest order is missing
if(is.na(regCoef[k+1])){
warning(paste("The maximum k accepted is", k-1, sep = " "))
break
}
# calculate transformation coefficients fx: from 1 to K
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csem
# rename variable with indicator k
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
cssemDat
#' @title Polynomial Method for CSSEM
#'
#' @description
#' A function to implement polynomial method in calculating CSSEM
#'
#' @param cssemDat a ata frame or matrix containing conversion table of raw score to scale score, and csem of raw score
#' @param K degree of polynomial regression
#'
#' @return a data frame containing CSSEM using Polynomial Method using different k values
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#'
#' @export
PolynomialMethod <- function(cssemDat, K){
# create data frame to store r square
rSquaredDat <- as.data.frame(matrix(nrow = K, ncol = 1))
# for loop to iterate different k
for (k in 1:K){
# fit model with k
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
# extract regression coefficients
regCoef <- summary(modelK)$coefficients[, 1]
# extract r square coefficient
rSquaredDat[k, 1]<- summary(modelK)$r.squared
# check whether regression coefficient of highest order is missing
if(is.na(regCoef[k+1])){
warning(paste("The maximum k accepted is", k-1, sep = " "))
break
}
# calculate transformation coefficients fx: from 1 to K
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csem
# rename variable with indicator k
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
return(list("RSquared" = as.matrix(rSquaredDat[1:k,]), "CSSEMPoly" = cssemDat))
}
#' @title CSSEM Polynomial Method
#'
#' @description
#' A function to calculate CSEM for Scale Scores using Polynomial Method based on Lord's CSEM
#'
#' @param numOfItem a numeric number indicating number of items
#' @param convTable a data frame or matrix containing conversion table of raw score to scale score
#' @param K a numeric number indicating highest degree of polynomial regression
#'
#' @return a data frame containing CSSEM using Polynomial Method
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#'
#' @export
CSSEMPolynomial <- function(numOfItem, convTable, K){
# csem Lord
csemLordDat <- CSEMLord(numOfItem)
# merge with converstion table
cssemDat <- merge(csemLordDat, convTable, by = "rawScore")
# change variable name
names(cssemDat)[names(cssemDat) == 'csemLord'] <- 'csem'
# apply polynomial method
cssemPolynomial <- PolynomialMethod(cssemDat, K)
# return results
return(list("RSquared" = cssemPolynomial$RSquared, "CSSEMPolynomial" = cssemPolynomial$CSSEMPoly))
}
CSSEMPolynomial(numOfItem, convTable_A_sub, 15)
CSEMIRT(theta, itemPara, "MLE")
theta <- convTable_A_Poly$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_A_Poly, by = "theta")
View(itemParaCSEM)
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
PolynomialMethod(itemParaCSEM, 20)
cssemPolynomial <- PolynomialMethod(cssemDat, K)
cssemPolynomial
list("RSquared" = cssemPolyMLE$RSquared, "CSSEMPolyMLE" = cssemPolyMLE$CSSEMPoly)
# theta
theta <- convTable_A_Poly$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_A_Poly, by = "theta")
# # transform inforamtion to csem
# itemParaCSEM$csemMLE <- sqrt(1/itemParaCSEM$infoSum)
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
cssemPolyMLE <- PolynomialMethod(cssemDat, K)
# return results
return(list("RSquared" = cssemPolyMLE$RSquared, "CSSEMPolyMLE" = cssemPolyMLE$CSSEMPoly))
list("RSquared" = cssemPolyMLE$RSquared, "CSSEMPolyMLE" = cssemPolyMLE$CSSEMPoly)
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, K)
list("RSquared" = cssemPolyMLE$RSquared, "CSSEMPolyMLE" = cssemPolyMLE$CSSEMPoly)
CSSEMIRTPoly(itemPara, convTable, K, estType)
### CSSEM IRT MLE Polynomial Method
CSSEMIRTPoly <- function(itemPara, convTable, K, estType){
# theta
theta <- convTable$theta
# return info for each theta
if (estType == "MLE"){
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, K)
# return results
return(list("RSquared" = cssemPolyMLE$RSquared, "CSSEMPolyMLE" = cssemPolyMLE$CSSEMPoly))
}else if (estType == "EAP"){
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "EAP"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
cssemPolyEAP <- PolynomialMethod(itemParaCSEM, K)
# return results
return(list("RSquared" = cssemPolyEAP$RSquared, "CSSEMPolyEAP" = cssemPolyEAP$CSSEMPoly))
}else{
warning("CSSEMIRTPoly function only supports MLE and EAP estimation method!")
}
}
CSSEMIRTPoly(itemPara, convTable_A_Poly, K, estType)
CSSEMIRTPoly(itemPara, convTable_A_Poly, K, "MLE")
CSSEMIRTPoly(itemPara, convTable_A_Poly, K, "EAP")
CSSEMIRTPoly(itemPara, convTable_A_Poly, K, "EAP")
### CSSEM IRT MLE Polynomial Method
CSSEMIRTPoly <- function(itemPara, convTable, K, estType){
# theta
theta <- convTable$theta
# return info for each theta
if (estType == "MLE"){
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
# call PM function
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, K)
# change variable name
names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'rawScore'] <- 'theta'
names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'csem'] <- 'csemMLE'
# return results
return(list("RSquared" = cssemPolyMLE$RSquared, "CSSEMPolyMLE" = cssemPolyMLE$CSSEMPoly))
}else if (estType == "EAP"){
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "EAP"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
# call PM function
cssemPolyEAP <- PolynomialMethod(itemParaCSEM, K)
# change variable name
names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'rawScore'] <- 'theta'
names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'csem'] <- 'csemEAP'
# return results
return(list("RSquared" = cssemPolyEAP$RSquared, "CSSEMPolyEAP" = cssemPolyEAP$CSSEMPoly))
}else{
warning("CSSEMIRTPoly function only supports MLE and EAP estimation method!")
}
}
CSSEMIRTPoly(itemPara, convTable_A_Poly, K, "EAP")
# call PM function
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, K)
View(cssemPolyMLE)
cssemPolyMLE$CSSEMPoly
names(cssemPolyMLE$CSSEMPoly) == 'rawScore'
names(cssemPolyMLE$CSSEMPoly)
lapply(cssemPolyMLE, names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'rawScore'] <- 'theta')
lapply(cssemPolyMLE, function(x) names(x$CSSEMPoly)[names(x$CSSEMPoly) == 'rawScore'] <- 'theta')
cssemPolyMLE
lapply(cssemPolyMLE$CSSEMPoly, function(x) names(x)[names(x) == 'rawScore'] <- 'theta')
cssemPolyMLE
names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'csem'] <- 'csemMLE'
cssemPolyMLE
### CSSEM IRT MLE Polynomial Method
CSSEMIRTPoly <- function(itemPara, convTable, K, estType){
# theta
theta <- convTable$theta
# return info for each theta
if (estType == "MLE"){
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
# call PM function
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, K)
# change variable name
names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'rawScore'] <- 'theta'
names(cssemPolyMLE$CSSEMPoly)[names(cssemPolyMLE$CSSEMPoly) == 'csem'] <- 'csemMLE'
# return results
return(list("RSquared" = cssemPolyMLE$RSquared, "CSSEMPolyMLE" = cssemPolyMLE$CSSEMPoly))
}else if (estType == "EAP"){
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara, "EAP"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
# call PM function
cssemPolyEAP <- PolynomialMethod(itemParaCSEM, K)
# change variable name
names(cssemPolyEAP$CSSEMPoly)[names(cssemPolyEAP$CSSEMPoly) == 'rawScore'] <- 'theta'
names(cssemPolyEAP$CSSEMPoly)[names(cssemPolyEAP$CSSEMPoly) == 'csem'] <- 'csemEAP'
# return results
return(list("RSquared" = cssemPolyEAP$RSquared, "CSSEMPolyEAP" = cssemPolyEAP$CSSEMPoly))
}else{
warning("CSSEMIRTPoly function only supports MLE and EAP estimation method!")
}
}
CSSEMIRTPoly(itemPara, convTable_A_Poly, K, "EAP")
CSSEMIRTPoly(itemPara, convTable_A_Poly, K, "MLE")
CSSEMIRTPoly(itemPara, convTable, K, "MLE")
CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
cssemMLEPolyDat
# raw score frequence
rawFreq <- as.data.frame(table(rowSums(rawData)))
rawFreq
names(rawFreq) <- c("rawScore", "freq")
rawFreq
cssemMLEPolyDat
table(rowSums(rawData))
table(rowSums(rawData))[2]
table(rowSums(rawData))[,2]
as.data.frame(table(rowSums(rawData)))[,2]
# cssem using Polynomial method
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
# raw score frequence
cssemMLEPolyDat$freq <- as.data.frame(table(rowSums(rawData)))[,2]
# cssem using Polynomial method
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
cssemMLEPolyDat
# raw score
cssemMLEPolyDat$rawScore <- c(0:nrow(itemPara))
# cssem using Polynomial method
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
cssemMLEPolyDat$rawScore <- c(0:nrow(itemPara))
cssemMLEPolyDat
# merge data
cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
cssemMLEPolyDat
?weighted.mean
weighted.mean(cssemMLEPolyDat$cssemPolyk4^2, cssemMLEPolyDat$wt)
sum(cssemMLEPolyDat$cssemPolyk4^2 * cssemMLEPolyDat$wt)
# cssem using Polynomial method
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
# raw score
cssemMLEPolyDat$rawScore <- c(0:nrow(itemPara))
# raw score frequence
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
# merge data
cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
# error variance
errorVar <- sum(cssemMLEPolyDat$cssemPolyk4^2 * cssemMLEPolyDat$wt)
# SS variance
SSVar <- sum(cssemMLEPolyDat$wt * (cssemMLEPolyDat$roundedSS - weighted.mean(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt))^2)
MLE <- 1 - errorVar/SSVar
MLE
error variance
errorVar <- sum(cssemMLEPolyDat$cssemPolyk5^2 * cssemMLEPolyDat$wt)
# SS variance
SSVar <- sum(cssemMLEPolyDat$wt * (cssemMLEPolyDat$roundedSS - weighted.mean(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt))^2)
RelMLEPoly <- 1 - errorVar/SSVar
RelMLEPoly
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
# error variance
errorVar <- sum(cssemMLEPolyDat$cssemPolyk6^2 * cssemMLEPolyDat$wt)
# SS variance
SSVar <- sum(cssemMLEPolyDat$wt * (cssemMLEPolyDat$roundedSS - weighted.mean(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt))^2)
RelMLEPoly <- 1 - errorVar/SSVar
RelMLEPoly
# cssem using Polynomial method
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
### RelMLEPoly
#rounded scale score reliability
K <- 20
# cssem using Polynomial method
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
# raw score
cssemMLEPolyDat$rawScore <- c(0:nrow(itemPara))
# raw score frequence
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
# merge data
cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
# error variance
errorVar <- sum(cssemMLEPolyDat$cssemPolyk6^2 * cssemMLEPolyDat$wt)
# SS variance
SSVar <- sum(cssemMLEPolyDat$wt * (cssemMLEPolyDat$roundedSS - weighted.mean(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt))^2)
RelMLEPoly <- 1 - errorVar/SSVar
RelMLEPoly
RelMLEPolyMat <- c()
## for loop
for(i in 1:K){
errorVar <- eval(parse(text=(paste("sum(cssemMLEPolyDat$cssemPolyk", i, "^2 * cssemMLEPolyDat$wt", sep = ""))))
RelMLEPolyMat[i] <- 1 - errorVar/SSVar
}
RelMLEPolyMat <- c()
## for loop
for(i in 1:K){
errorVar <- eval(parse(text=(paste("sum(cssemMLEPolyDat$cssemPolyk", i, "^2 * cssemMLEPolyDat$wt)", sep = ""))))
RelMLEPolyMat[i] <- 1 - errorVar/SSVar
}
RelMLEPolyMat
RelMLEPolyMat
summary(RelMLEPolyMat)
RelMLEPolyMat[RelMLEPolyMat>0]
summary(RelMLEPolyMat[RelMLEPolyMat>0])
# for loop to calculate reliability for scale score
RelMLEPolyDat <- as.data.frame(matrix(nrow = K, ncol = 2))
for(i in 1:K){
errorVar <- eval(parse(text=(paste("sum(cssemMLEPolyDat$cssemPolyk", i, "^2 * cssemMLEPolyDat$wt)", sep = ""))))
RelMLEPolyDat[i,2] <- 1 - errorVar/SSVar
}
summary(RelMLEPolyMat[RelMLEPolyMat>0])
RelMLEPolyDat
RelMLEPolyDat <- as.data.frame(matrix(nrow = K, ncol = 1))
for(i in 1:K){
errorVar <- eval(parse(text=(paste("sum(cssemMLEPolyDat$cssemPolyk", i, "^2 * cssemMLEPolyDat$wt)", sep = ""))))
RelMLEPolyDat[i,2] <- 1 - errorVar/SSVar
}
RelMLEPolyDat$kValue <- 1:K
RelMLEPolyDat
# for loop to calculate reliability for scale score
RelMLEPolyDat <- as.data.frame(matrix(nrow = K, ncol = 1))
for(i in 1:K){
errorVar <- eval(parse(text=(paste("sum(cssemMLEPolyDat$cssemPolyk", i, "^2 * cssemMLEPolyDat$wt)", sep = ""))))
RelMLEPolyDat[i,1] <- 1 - errorVar/SSVar
}
RelMLEPolyDat$kValue <- 1:K
RelMLEPolyDat
RelMLEPolyDat[RelMLEPolyMat$V1>0 && RelMLEPolyMat$V1!=0,]
RelMLEPolyDat[RelMLEPolyDat$V1>0 && RelMLEPolyDat$V1!=0,]
RelMLEPolyDat[RelMLEPolyDat$V1 > 0 && RelMLEPolyDat$V1 != 1,]
RelMLEPolyDat$V1 != 1
RelMLEPolyDat$V1 > 0
RelMLEPolyDat$V1 > 0 && RelMLEPolyDat$V1 != 1
RelMLEPolyDat$V1 > 0 & RelMLEPolyDat$V1 != 1
RelMLEPolyDat[RelMLEPolyDat$V1 > 0 & RelMLEPolyDat$V1 != 1,]
list("kValue" = RelMLEPolyDat$kValue, "RelMLEPoly" = RelMLEPolyDat$V1)
# select reliability values not equal to 1, and larger than 0
RelMLEPolyDat <- RelMLEPolyDat[RelMLEPolyDat$V1 > 0 & RelMLEPolyDat$V1 != 1,]
# return results
return(list("kValue" = RelMLEPolyDat$kValue, "RelMLEPoly" = RelMLEPolyDat$V1))
list("kValue" = RelMLEPolyDat$kValue, "RelMLEPoly" = RelMLEPolyDat$V1)
RelIRTPoly <- function(itemPara, convTable, K, estType, rawData)
### RelMLEPoly
#rounded scale score reliability
RelIRTPoly <- function(itemPara, convTable, K, estType, rawData){
# raw score frequence
rawFreq <- as.data.frame(table(rowSums(rawData)))
names(rawFreq) <- c("rawScore", "freq")
if (estType == "MLE"){
# cssem using Polynomial method
cssemMLEPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "MLE")$CSSEMPolyMLE
# raw score
cssemMLEPolyDat$rawScore <- c(0:nrow(itemPara))
# merge data
cssemMLEPolyDat <- merge(cssemMLEPolyDat, rawFreq, by = "rawScore")
# weight
cssemMLEPolyDat$wt <- cssemMLEPolyDat$freq / sum(cssemMLEPolyDat$freq)
# SS variance
SSVar <- sum(cssemMLEPolyDat$wt * (cssemMLEPolyDat$roundedSS - weighted.mean(cssemMLEPolyDat$roundedSS, cssemMLEPolyDat$wt))^2)
# for loop to calculate reliability for scale score
RelMLEPolyDat <- as.data.frame(matrix(nrow = K, ncol = 1))
for(i in 1:K){
errorVar <- eval(parse(text=(paste("sum(cssemMLEPolyDat$cssemPolyk", i, "^2 * cssemMLEPolyDat$wt)", sep = ""))))
RelMLEPolyDat[i,1] <- 1 - errorVar/SSVar
}
RelMLEPolyDat$kValue <- 1:K
# select reliability values not equal to 1, and larger than 0
RelMLEPolyDat <- RelMLEPolyDat[RelMLEPolyDat$V1 > 0 & RelMLEPolyDat$V1 != 1,]
# return results
return(list("kValue" = RelMLEPolyDat$kValue, "RelMLEPoly" = RelMLEPolyDat$V1))
}else if (estType == "EAP"){
# cssem using Polynomial method
cssemEAPPolyDat <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, K, "EAP")$CSSEMPolyEAP
# raw score
cssemEAPPolyDat$rawScore <- c(0:nrow(itemPara))
# merge data
cssemEAPPolyDat <- merge(cssemEAPPolyDat, rawFreq, by = "rawScore")
# weight
cssemEAPPolyDat$wt <- cssemEAPPolyDat$freq / sum(cssemEAPPolyDat$freq)
# SS variance
SSVar <- sum(cssemEAPPolyDat$wt * (cssemEAPPolyDat$roundedSS - weighted.mean(cssemEAPPolyDat$roundedSS, cssemEAPPolyDat$wt))^2)
# for loop to calculate reliability for scale score
RelEAPPolyDat <- as.data.frame(matrix(nrow = K, ncol = 1))
for(i in 1:K){
errorVar <- eval(parse(text=(paste("sum(cssemEAPPolyDat$cssemPolyk", i, "^2 * cssemEAPPolyDat$wt)", sep = ""))))
RelEAPPolyDat[i,1] <- 1 - errorVar/SSVar
}
RelEAPPolyDat$kValue <- 1:K
# select reliability values not equal to 1, and larger than 0
RelEAPPolyDat <- RelEAPPolyDat[RelEAPPolyDat$V1 > 0 & RelEAPPolyDat$V1 != 1,]
# return results
return(list("kValue" = RelEAPPolyDat$kValue, "RelEAPPoly" = RelEAPPolyDat$V1))
}else{
warning("RelIRTPolyfunction only supports MLE and EAP estimation method!")
}
}
RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "MLE", rawData_A)
RelIRTPoly(itemPara_B, convTable_B_Poly, 20, "MLE", rawData_B)
RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "EAP", rawData_A)
RelIRTPoly(itemPara_B, convTable_B_Poly, 20, "EAP", rawData_B)
