# return(list("RSquared" = as.matrix(rSquaredDat[1:k,]), "CSSEMPoly" = cssemDat))
regCoefDat[[4]]  ## get coefficients for k = 4
# # SS formula
#
# SS = 118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4
#
# f=expression(118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4)
# D(f,'x')
#
#
# # CSSEM formula
#
# CSSEM = 3.909028972 - 0.360085771 * (2 * x) - 0.036053623 * (3 * x^2) + 0.009014156 * (4 * x^3)
# SS formula
# names(itemParaCSEM) <- c("theta", 'csemMLE',"scaleScore")
# theta
theta_New <- NormalQuadraPoints(41)$nodes
weights_New <- NormalQuadraPoints(41)$weights
# CSEM MLE
itemParaCSEM_New <- as.data.frame(CSEMIRT(theta_New, itemPara_B, "MLE"))
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
#   cssemNew = 3.92088450 -0.47021240 * (2 * csemMLE) -0.03740998  * (3 * csemMLE^2) + 0.01328610 * (4 * csemMLE^3)
#   roundedSS = round(scaleScoreNew)
# })
# form B
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
#   cssemNew = 3.92088450 -0.47021240 * (2 * csemEAP) -0.03740998  * (3 * csemEAP^2) + 0.01328610 * (4 * csemEAP^3)
#   roundedSS = round(scaleScoreNew)
# })
# form A
itemParaCSEM_New <- within(itemParaCSEM_New,{
scaleScoreNew =  118.263733790 + 3.909028972 * theta -0.360085771 * theta^2 -0.036053623 * theta^3 + 0.009014156 * theta^4
cssemNew = 3.909028972 -0.360085771 * (2 * csemMLE) -0.036053623  * (3 * csemMLE^2) + 0.009014156 * (4 * csemMLE^3)
roundedSS = round(scaleScoreNew)
})
itemParaCSEM_New$weights_new <- weights_New
# SS variance
SSVar <- sum(itemParaCSEM_New$weights_new * (itemParaCSEM_New$roundedSS - weighted.mean(itemParaCSEM_New$roundedSS, itemParaCSEM_New$weights_new))^2)
# error variance
errorVar <- sum(itemParaCSEM_New$cssemNew * itemParaCSEM_New$weights_new)
# reliability
RelMLEPolyNew <- 1 - errorVar/SSVar
RelMLEPolyNew
thod two --------------------------------------------------------------------
# theta
theta <- convTable_B$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara_B, "MLE"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_B_Poly, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
# call PM function
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, 20)
cssemDat <- itemParaCSEM
K <- 20
# create data frame to store r square
rSquaredDat <- as.data.frame(matrix(nrow = K, ncol = 1))
regCoefDat <- list()
# for loop to iterate different k
for (k in 1:K){
# fit model with k
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
# extract regression coefficients
regCoef <- summary(modelK)$coefficients[, 1]
regCoefDat[[k]] <- summary(modelK)$coefficients
# extract r square coefficient
rSquaredDat[k, 1]<- summary(modelK)$r.squared
# check whether regression coefficient of highest order is missing
if(is.na(regCoef[k+1])){
message(paste("The maximum k accepted is", k-1, sep = " "))
break
}
# calculate transformation coefficients fx: from 1 to K
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csem
# rename variable with indicator k
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
# return(list("RSquared" = as.matrix(rSquaredDat[1:k,]), "CSSEMPoly" = cssemDat))
regCoefDat[[4]]  ## get coefficients for k = 4
# # SS formula
#
# SS = 118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4
#
# f=expression(118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4)
# D(f,'x')
#
#
# # CSSEM formula
#
# CSSEM = 3.909028972 - 0.360085771 * (2 * x) - 0.036053623 * (3 * x^2) + 0.009014156 * (4 * x^3)
# SS formula
# names(itemParaCSEM) <- c("theta", 'csemMLE',"scaleScore")
# theta
theta_New <- NormalQuadraPoints(41)$nodes
weights_New <- NormalQuadraPoints(41)$weights
# CSEM MLE
itemParaCSEM_New <- as.data.frame(CSEMIRT(theta_New, itemPara_B, "MLE"))
itemParaCSEM_New <- within(itemParaCSEM_New,{
scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
cssemNew = 3.92088450 -0.47021240 * (2 * csemMLE) -0.03740998  * (3 * csemMLE^2) + 0.01328610 * (4 * csemMLE^3)
roundedSS = round(scaleScoreNew)
})
# form B
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
#   cssemNew = 3.92088450 -0.47021240 * (2 * csemEAP) -0.03740998  * (3 * csemEAP^2) + 0.01328610 * (4 * csemEAP^3)
#   roundedSS = round(scaleScoreNew)
# })
# form A
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.263733790 + 3.909028972 * theta -0.360085771 * theta^2 -0.036053623 * theta^3 + 0.009014156 * theta^4
#   cssemNew = 3.909028972 -0.360085771 * (2 * csemMLE) -0.036053623  * (3 * csemMLE^2) + 0.009014156 * (4 * csemMLE^3)
#   roundedSS = round(scaleScoreNew)
# })
itemParaCSEM_New$weights_new <- weights_New
# SS variance
SSVar <- sum(itemParaCSEM_New$weights_new * (itemParaCSEM_New$roundedSS - weighted.mean(itemParaCSEM_New$roundedSS, itemParaCSEM_New$weights_new))^2)
# error variance
errorVar <- sum(itemParaCSEM_New$cssemNew * itemParaCSEM_New$weights_new)
# reliability
RelMLEPolyNew <- 1 - errorVar/SSVar
RelMLEPolyNew
### method two --------------------------------------------------------------------
# theta
theta <- convTable_B$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara_B, "EAP"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_B_Poly, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
# call PM function
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, 20)
cssemDat <- itemParaCSEM
K <- 20
# create data frame to store r square
rSquaredDat <- as.data.frame(matrix(nrow = K, ncol = 1))
regCoefDat <- list()
# for loop to iterate different k
for (k in 1:K){
# fit model with k
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
# extract regression coefficients
regCoef <- summary(modelK)$coefficients[, 1]
regCoefDat[[k]] <- summary(modelK)$coefficients
# extract r square coefficient
rSquaredDat[k, 1]<- summary(modelK)$r.squared
# check whether regression coefficient of highest order is missing
if(is.na(regCoef[k+1])){
message(paste("The maximum k accepted is", k-1, sep = " "))
break
}
# calculate transformation coefficients fx: from 1 to K
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csem
# rename variable with indicator k
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
# return(list("RSquared" = as.matrix(rSquaredDat[1:k,]), "CSSEMPoly" = cssemDat))
regCoefDat[[4]]  ## get coefficients for k = 4
# # SS formula
#
# SS = 118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4
#
# f=expression(118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4)
# D(f,'x')
#
#
# # CSSEM formula
#
# CSSEM = 3.909028972 - 0.360085771 * (2 * x) - 0.036053623 * (3 * x^2) + 0.009014156 * (4 * x^3)
# SS formula
# names(itemParaCSEM) <- c("theta", 'csemMLE',"scaleScore")
# theta
theta_New <- NormalQuadraPoints(41)$nodes
weights_New <- NormalQuadraPoints(41)$weights
# CSEM MLE
itemParaCSEM_New <- as.data.frame(CSEMIRT(theta_New, itemPara_B, "EAP"))
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
#   cssemNew = 3.92088450 -0.47021240 * (2 * csemMLE) -0.03740998  * (3 * csemMLE^2) + 0.01328610 * (4 * csemMLE^3)
#   roundedSS = round(scaleScoreNew)
# })
# form B
itemParaCSEM_New <- within(itemParaCSEM_New,{
scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
cssemNew = 3.92088450 -0.47021240 * (2 * csemEAP) -0.03740998  * (3 * csemEAP^2) + 0.01328610 * (4 * csemEAP^3)
roundedSS = round(scaleScoreNew)
})
# form A
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.263733790 + 3.909028972 * theta -0.360085771 * theta^2 -0.036053623 * theta^3 + 0.009014156 * theta^4
#   cssemNew = 3.909028972 -0.360085771 * (2 * csemMLE) -0.036053623  * (3 * csemMLE^2) + 0.009014156 * (4 * csemMLE^3)
#   roundedSS = round(scaleScoreNew)
# })
itemParaCSEM_New$weights_new <- weights_New
# SS variance
SSVar <- sum(itemParaCSEM_New$weights_new * (itemParaCSEM_New$roundedSS - weighted.mean(itemParaCSEM_New$roundedSS, itemParaCSEM_New$weights_new))^2)
# error variance
errorVar <- sum(itemParaCSEM_New$cssemNew * itemParaCSEM_New$weights_new)
# reliability
RelMLEPolyNew <- 1 - errorVar/SSVar
RelMLEPolyNew
RelMLEPoly_A <- RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "MLE", rawData_A)
RelMLEPoly_A
RelMLEPoly_B <- RelIRTPoly(itemPara_B, convTable_B_Poly, 20, "MLE", rawData_B)
RelMLEPoly_B
RelEAPPoly_A <- RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "EAP", rawData_A)
RelEAPPoly_A
RelEAPPoly_B <- RelIRTPoly(itemPara_B, convTable_B_Poly, 20, "EAP", rawData_B)
RelEAPPoly_B
merge(as.data.frame(RelMLEPoly_A), as.data.frame(RelMLEPoly_B), as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B), by = "kValue")
as.data.frame(RelMLEPoly_A)
as.data.frame(RelMLEPoly_B)
as.data.frame(RelEAPPoly_A)
as.data.frame(RelEAPPoly_B)
merge(as.data.frame(RelMLEPoly_A), as.data.frame(RelMLEPoly_B), as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B), by = "kValue")
rbind(as.data.frame(RelMLEPoly_A), as.data.frame(RelMLEPoly_B), as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B))
cbind(as.data.frame(RelMLEPoly_A), as.data.frame(RelMLEPoly_B), as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B))
merge(as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B))
merge(as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B), by = "kValue")
write(EAP, "EAP.txt")
EAP <- merge(EAP, as.data.frame(RelMLEPoly_B),  by = "kValue")
EAP <- merge(as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B), by = "kValue")
EAP <- merge(EAP, as.data.frame(RelMLEPoly_B),  by = "kValue")
write(EAP, "EAP.txt")
write.table(EAP, "EAP.txt")
write.csv(EAP, "EAP.csv")
RelMLEPoly_A
write.csv(RelMLEPoly_A, "RelMLEPoly_A.csv")
write.csv(RelMLEPoly_B, "RelMLEPoly_B.csv")
RelEAPPoly_A
library(EMReliability)
# source("R/CSSEMPolynomial.R") # numOfItem, convTable, K
# source("R/CSEMIRT.R") # itemPara
# source("R/CSSEMIRT.R") # itemPara, convTable
# load library
library(EMReliability)
# read raw data
rawData_A <- read.table("TestData/RawDataFormX.txt")
rawData_B <- read.table("TestData/RawDataFormY.txt")
# read item parameters from txt file
itemPara_A <- read.table("TestData/ItemParaFormX.txt")
names(itemPara_A) <- c("b", "a")
itemPara_A[,"a"] <- itemPara_A[,"a"]/1.702
itemPara_B <- read.table("TestData/ItemParaFormY.txt")
names(itemPara_B) <- c("b", "a")
itemPara_B[,"a"] <- itemPara_B[,"a"]/1.702
# read conversion tables
convTable_A <- read.csv("TestData/ConversionTableFormX.csv")
convTable_A$roundedSS <- round(convTable_A$unroundedSS)
convTable_B <- read.csv("TestData/ConversionTableFormY.csv")
convTable_B$roundedSS <- round(convTable_B$unroundedSS)
convTable_A_Poly <- convTable_A[,c("theta", "roundedSS")]
convTable_B_Poly <- convTable_B[,c("theta", "roundedSS")]
# test help functions ------------------------------------
NormalQuadraPoints(41)
LordWingersky(c(0.9,0.9,0.9))
Info(NormalQuadraPoints(41)$nodes, itemPara_A, "EAP")
# CronbachAlpha & GT
CronbachAlpha_A <- CronbachAlpha(rawData_A)
CronbachAlpha_A
CronbachAlpha_B <- CronbachAlpha(rawData_B)
CronbachAlpha_B
# Feldt
Feldt_A <- Feldt(rawData_A)
Feldt_A
Feldt_B <- Feldt(rawData_B)
Feldt_B
# test reliability IRT
TestRelIRT_A <- TestRelIRT(itemPara_A)
TestRelIRT_A
TestRelIRT_B <- TestRelIRT(itemPara_B)
TestRelIRT_B
# marginal reliability MLE
MarginalRelMLE_A <- MarginalRelIRT(itemPara_A, "MLE")
MarginalRelMLE_A
MarginalRelMLE_B <- MarginalRelIRT(itemPara_B, "MLE")
MarginalRelMLE_B
# marginal reliability EAP
MarginalRelEAP_A <- MarginalRelIRT(itemPara_A, "EAP")
MarginalRelEAP_A
MarginalRelEAP_B <- MarginalRelIRT(itemPara_B, "EAP")
MarginalRelEAP_B
# Kolen's method
KolenRelIRT_A <- KolenRelIRT(itemPara_A, convTable_A)
KolenRelIRT_A
KolenRelIRT_B <- KolenRelIRT(itemPara_B, convTable_B)
KolenRelIRT_B
# Reliability for rounded SS using polynomial method
RelMLEPoly_A <- RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "MLE", rawData_A)
RelMLEPoly_A
RelMLEPoly_B <- RelIRTPoly(itemPara_B, convTable_B_Poly, 20, "MLE", rawData_B)
RelMLEPoly_B
RelEAPPoly_A <- RelIRTPoly(itemPara_A, convTable_A_Poly, 20, "EAP", rawData_A)
RelEAPPoly_A
RelEAPPoly_B <- RelIRTPoly(itemPara_B, convTable_B_Poly, 20, "EAP", rawData_B)
RelEAPPoly_B
EAP <- merge(as.data.frame(RelEAPPoly_A), as.data.frame(RelEAPPoly_B), by = "kValue")
EAP <- merge(EAP, as.data.frame(RelMLEPoly_B),  by = "kValue")
write.csv(EAP, "EAP.csv")
write.csv(RelMLEPoly_A, "RelMLEPoly_A.csv")
write.csv(RelMLEPoly_B, "RelMLEPoly_B.csv")
### CSEM --------------------------------------------------------------
# CSEM Lord
csemLord <- CSEMLord(40)
csemLord
# CSEM MLE
csemMLE_A <- CSEMIRT(NormalQuadraPoints(41)$nodes, itemPara_A, "MLE")
csemMLE_A
csemMLE_B <- CSEMIRT(NormalQuadraPoints(41)$nodes, itemPara_B, "MLE")
csemMLE_B
# CSEM EAP
csemEAP_A <- CSEMIRT(NormalQuadraPoints(41)$nodes, itemPara_A, "EAP")
csemEAP_A
csemEAP_B <- CSEMIRT(NormalQuadraPoints(41)$nodes, itemPara_B, "EAP")
csemEAP_B
### CSSEM -------------------------------------------------------------
# CSSEM Binomial
csemBinomial_A <- CSSEMBinomial(40, convTable_A)
csemBinomial_A
csemBinomial_B <- CSSEMBinomial(40, convTable_B)
csemBinomial_B
# CSSEM Polynomial
# number of item
numOfItem <- 40
convTable_A_sub <- convTable_A[,c("rawScore", "roundedSS")]
convTable_B_sub <- convTable_B[,c("rawScore", "roundedSS")]
cssemPolynomial_A <- CSSEMPolynomial(numOfItem, convTable_A_sub, 20)
cssemPolynomial_A
cssemPolynomial_B <- CSSEMPolynomial(numOfItem, convTable_B_sub, 20)
cssemPolynomial_B
# CSSEM Kolen's Method
cssemKolen_A <- CSSEMKolen(itemPara_A, convTable_A)
cssemKolen_A
cssemKolen_B <- CSSEMKolen(itemPara_B, convTable_B)
cssemKolen_B
# CSSEM IRT MLE Polynomial
cssemMLEPoly_A <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, 20, "MLE")
cssemMLEPoly_A
cssemMLEPoly_B <- CSSEMIRTPoly(itemPara_B, convTable_B_Poly, 20, "MLE")
cssemMLEPoly_B
# CSSEM IRT EAP Polynomial
cssemEAPPoly_A <- CSSEMIRTPoly(itemPara_A, convTable_A_Poly, 20, "EAP")
cssemEAPPoly_A
cssemEAPPoly_B <- CSSEMIRTPoly(itemPara_B, convTable_B_Poly, 20, "EAP")
cssemEAPPoly_B
### CSSEM IRT Polynomial MLE New -----------------------------------------------
postDist <- read.table("TestData/PosteriorDistribution.txt.txt", sep = " ")
postDist <- read.table("TestData\PosteriorDistribution.txt.txt", sep = " ")
postDist <- read.table("TestData/PosteriorDistributio.txt", sep = " ")
postDist <- read.table("TestData/PosteriorDistribution.txt", sep = " ")
View(postDist)
postDist <- read.table("TestData/PosteriorDistribution.txt", sep = " ")
View(postDist)
postDist <- read.table("TestData/PosteriorDistribution.txt", sep = " ")
### method two --------------------------------------------------------------------
# theta
theta <- convTable_B$theta
# CSEM MLE
itemParaCSEM <- as.data.frame(CSEMIRT(theta, itemPara_B, "EAP"))
# merge data
itemParaCSEM <- merge(itemParaCSEM, convTable_B_Poly, by = "theta")
# change name to fit Polynomial Method function
names(itemParaCSEM) <- c("rawScore", "csem", "roundedSS")
# call PM function
cssemPolyMLE <- PolynomialMethod(itemParaCSEM, 20)
cssemDat <- itemParaCSEM
K <- 20
# create data frame to store r square
rSquaredDat <- as.data.frame(matrix(nrow = K, ncol = 1))
regCoefDat <- list()
# for loop to iterate different k
for (k in 1:K){
# fit model with k
modelK <- lm(roundedSS ~ poly(rawScore, k, raw=TRUE), cssemDat)
# extract regression coefficients
regCoef <- summary(modelK)$coefficients[, 1]
regCoefDat[[k]] <- summary(modelK)$coefficients
# extract r square coefficient
rSquaredDat[k, 1]<- summary(modelK)$r.squared
# check whether regression coefficient of highest order is missing
if(is.na(regCoef[k+1])){
message(paste("The maximum k accepted is", k-1, sep = " "))
break
}
# calculate transformation coefficients fx: from 1 to K
cssemDat$fx <- 0
i <- k
while(i > 1){
cssemDat$fx <- cssemDat$fx +  regCoef[i+1] * (i * cssemDat$rawScore^(i-1))
i <- i-1
}
cssemDat$fx <- cssemDat$fx + regCoef[i+1]
# calculate cssem using polynomial method
cssemDat$cssemPoly <- cssemDat$fx * cssemDat$csem
# rename variable with indicator k
names(cssemDat)[names(cssemDat) == 'cssemPoly'] <- paste("cssemPolyk", k, sep = "")
}
# return(list("RSquared" = as.matrix(rSquaredDat[1:k,]), "CSSEMPoly" = cssemDat))
regCoefDat[[4]]  ## get coefficients for k = 4
# # SS formula
#
# SS = 118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4
#
# f=expression(118.263733790 + 3.909028972 * x -0.360085771 * x^2 -0.036053623 * x^3 + 0.009014156 * x^4)
# D(f,'x')
#
#
# # CSSEM formula
#
# CSSEM = 3.909028972 - 0.360085771 * (2 * x) - 0.036053623 * (3 * x^2) + 0.009014156 * (4 * x^3)
# SS formula
# names(itemParaCSEM) <- c("theta", 'csemMLE',"scaleScore")
# theta
theta_New <- NormalQuadraPoints(41)$nodes
weights_New <- NormalQuadraPoints(41)$weights
# CSEM MLE
itemParaCSEM_New <- as.data.frame(CSEMIRT(theta_New, itemPara_B, "EAP"))
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
#   cssemNew = 3.92088450 -0.47021240 * (2 * csemMLE) -0.03740998  * (3 * csemMLE^2) + 0.01328610 * (4 * csemMLE^3)
#   roundedSS = round(scaleScoreNew)
# })
# form B
itemParaCSEM_New <- within(itemParaCSEM_New,{
scaleScoreNew =  118.35478428 + 3.92088450 * theta -0.47021240 * theta^2 -0.03740998 * theta^3 + 0.01328610 * theta^4
cssemNew = 3.92088450 -0.47021240 * (2 * csemEAP) -0.03740998  * (3 * csemEAP^2) + 0.01328610 * (4 * csemEAP^3)
roundedSS = round(scaleScoreNew)
})
# form A
# itemParaCSEM_New <- within(itemParaCSEM_New,{
#   scaleScoreNew =  118.263733790 + 3.909028972 * theta -0.360085771 * theta^2 -0.036053623 * theta^3 + 0.009014156 * theta^4
#   cssemNew = 3.909028972 -0.360085771 * (2 * csemMLE) -0.036053623  * (3 * csemMLE^2) + 0.009014156 * (4 * csemMLE^3)
#   roundedSS = round(scaleScoreNew)
# })
### read new posterior distribution rates
postDist <- read.table("TestData/PosteriorDistribution.txt", sep = " ")
itemParaCSEM_New$weights_new <- postDist$V2
# SS variance
SSVar <- sum(itemParaCSEM_New$weights_new * (itemParaCSEM_New$roundedSS - weighted.mean(itemParaCSEM_New$roundedSS, itemParaCSEM_New$weights_new))^2)
# error variance
errorVar <- sum(itemParaCSEM_New$cssemNew * itemParaCSEM_New$weights_new)
# reliability
RelMLEPolyNew <- 1 - errorVar/SSVar
RelMLEPolyNew
postDist <- read.table("TestData/PosteriorDistribution.txt", sep = "\t")
postDist <- read.table("TestData/PosteriorDistribution.txt", sep = " ")
postDist <- read.table("TestData/PosteriorDistribution.txt", sep = " ")
plot(postDist$V1, postDist$V2)
plot(postDist$V1, postDist$V2)
b <- c(-0.4, -0.3, -0.2, -0.1, 0.0, 0.0, 0.1, 0.2, 0.3, 0.4)
a <- c(1.0, 1.5, 1.2, 1.3, 1.0, 1.6, 1.6, 1.4, 1.1, 1.7)
theta <- seq(-3, 3, 0.1)
J <- length(b)
ii <- matrix(rep(0, length(theta)*J), nrow=length(theta))
i <- rep(0, length(theta))
for (j in 1:J) {
P <- 1 / (1 + exp(-a[j] * (theta - b[j])))
ii[,j] <- a[j]**2 * P * (1.0 - P)
i <- i + ii[,j]
}
plot(theta, i, xlim=c(-3,3), ylim=c(0,10), type="l",
xlab="Ability", ylab="Information",
main="Test Information Function")
b <- c(-0.4, -0.3, -0.2, -0.1, 0.0, 0.0, 0.1, 0.2, 0.3, 0.4)
a <- c(1.0, 1.5, 1.2, 1.3, 1.0, 1.6, 1.6, 1.4, 1.1, 1.7)
theta <- seq(-3, 3, 0.01)
J <- length(b)
ii <- matrix(rep(0, length(theta)*J), nrow=length(theta))
i <- rep(0, length(theta))
for (j in 1:J) {
P <- 1 / (1 + exp(-a[j] * (theta - b[j])))
ii[,j] <- a[j]**2 * P * (1.0 - P)
i <- i + ii[,j]
}
plot(theta, i, xlim=c(-3,3), ylim=c(0,10), type="l",
xlab="Ability", ylab="Information",
main="Test Information Function")
View(ii)
b <- c(0, -0.3, -0.2, -0.1, 0.0, 0.0, 0.1, 0.2, 0.3, 0.4)
a <- c(1.0, 1.5, 1.2, 1.3, 1.0, 1.6, 1.6, 1.4, 1.1, 1.7)
theta <- seq(-3, 3, 0.01)
J <- length(b)
ii <- matrix(rep(0, length(theta)*J), nrow=length(theta))
i <- rep(0, length(theta))
for (j in 1:J) {
P <- 1 / (1 + exp(-a[j] * (theta - b[j])))
ii[,j] <- a[j]**2 * P * (1.0 - P)
i <- i + ii[,j]
}
plot(theta, i, xlim=c(-3,3), ylim=c(0,10), type="l",
xlab="Ability", ylab="Information",
main="Test Information Function")
