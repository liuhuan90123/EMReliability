PQ = P * Q
})
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
View(itemParaInfo)
names(itemParaInfo) <- c("theta", "infoSum")
View(itemParaInfo)
itemParaInfo$weights <- quadPoints$weights
View(itemParaRep)
# add weights for each theta
itemParaRep$weights <- quadPoints$weights
# weighted information
itemParaRep$infoWeighted <- itemParaRep$weights * itemParaRep$info
itemParaInfoMLE <- aggregate(itemParaRep$infoWeighted, by=list(Category=itemParaRep$theta), FUN=sum)
View(itemParaInfoMLE)
View(itemParaInfoMLE)
marginalRelMLE <- sum(itemParaInfoMLE$x)/(sum(itemParaInfoMLE$x) + 1)
marginalRelMLE
View(itemParaInfo)
itemParaInfoEAP <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfoEAP) <- c("theta", "infoSum")
# add weights for each theta
itemParaInfo$weights <- quadPoints$weights
View(itemParaInfoEAP)
itemParaInfoEAP$weights <- quadPoints$weights
itemParaInfoEAP$infoSumInv <- 1 / (itemParaInfoEAP$infoSum + 1) # cobtributed by population
marginalRelEAP <- 1 - sum(itemParaInfoEAP$infoSumInv * itemParaInfoEAP$weights)
marginalRelEAP
### Marginal Reliability of IRT
library(rpf)
library(statmod)
# read item parameters from flexMIRT output
itemPara <- matrix(read.flexmirt("TestData/UShistory_X-prm.txt")$G1$param, ncol = 2, byrow = TRUE)
# transform item parameters to the logistic metric
itemPara[,1] <- itemPara[,1]/1.701
itemPara <- as.data.frame(itemPara)
names(itemPara) <- c("a", "b")
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
PQ = P * Q
})
# MLE method -------------------------------
# add weights for each theta
itemParaRep$weights <- quadPoints$weights
# weighted information
itemParaRep$infoWeighted <- itemParaRep$weights * itemParaRep$info
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$infoWeighted, by=list(Category=itemParaRep$theta), FUN=sum)
marginalRelMLE <- sum(itemParaInfoMLE$x)/(sum(itemParaInfoMLE$x) + 1)
marginalRelMLE
# EAP method ------------------------------
# sum information by theta
itemParaInfoEAP <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfoEAP) <- c("theta", "infoSum")
# add weights for each theta
itemParaInfoEAP$weights <- quadPoints$weights
# inverse of information
itemParaInfoEAP$infoSumInv <- 1 / (itemParaInfoEAP$infoSum + 1) # cobtributed by population
marginalRelEAP <- 1 - sum(itemParaInfoEAP$infoSumInv * itemParaInfoEAP$weights)
marginalRelEAP
itemPara_n <- read.table("TestData/ItemParaFormX.txt")
View(itemPara_n)
itemPara_n <- read.table("TestData/ItemParaFormX.txt")
MarginalRelMLE <- function(itemPara){
# transform item parameters to the logistic metric
itemPara[,1] <- itemPara[,1]/1.701
itemPara <- as.data.frame(itemPara)
names(itemPara) <- c("a", "b")
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
PQ = P * Q
})
## MLE method -------------------------------
# add weights for each theta
itemParaRep$weights <- quadPoints$weights
# weighted information
itemParaRep$infoWeighted <- itemParaRep$weights * itemParaRep$info
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$infoWeighted, by=list(Category=itemParaRep$theta), FUN=sum)
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$x)/(sum(itemParaInfoMLE$x) + 1)
marginalRelMLE
}
MarginalRelMLE(itemPara)
View(itemPara)
MarginalRelMLE <- function(itemPara){
# transform item parameters to the logistic metric
itemPara[,1] <- itemPara[,1]/1.701
itemPara <- as.data.frame(itemPara)
names(itemPara) <- c("b", "a")
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
PQ = P * Q
})
## MLE method -------------------------------
# add weights for each theta
itemParaRep$weights <- quadPoints$weights
# weighted information
itemParaRep$infoWeighted <- itemParaRep$weights * itemParaRep$info
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$infoWeighted, by=list(Category=itemParaRep$theta), FUN=sum)
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$x)/(sum(itemParaInfoMLE$x) + 1)
marginalRelMLE
}
MarginalRelMLE(itemPara)
View(itemPara)
View(itemPara_n)
itemPara <- read.table("TestData/ItemParaFormX.txt")
MarginalRelMLE <- function(itemPara){
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
PQ = P * Q
})
## MLE method -------------------------------
# add weights for each theta
itemParaRep$weights <- quadPoints$weights
# weighted information
itemParaRep$infoWeighted <- itemParaRep$weights * itemParaRep$info
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$infoWeighted, by=list(Category=itemParaRep$theta), FUN=sum)
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$x)/(sum(itemParaInfoMLE$x) + 1)
marginalRelMLE
}
MarginalRelMLE(itemPara)
# read item parameters from flexMIRT output
itemPara <- read.table("TestData/ItemParaFormX.txt")
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
View(itemParaRep)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
# add weights for each theta
itemParaRep$weights <- quadPoints$weights
# weighted information
itemParaRep$infoWeighted <- itemParaRep$weights * itemParaRep$info
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$infoWeighted, by=list(Category=itemParaRep$theta), FUN=sum)
View(itemParaInfoMLE)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
View(itemParaRep)
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
View(itemPara)
View(itemParaRep)
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
View(itemParaInfoMLE)
# add weights for each theta
itemParaInfoMLE$weights <- quadPoints$weights
# weighted information
itemParaInfoMLE$infoWeighted <- itemParaInfoMLE$weights * itemParaInfoMLE$x
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$infoWeighted)/(sum(itemParaInfoMLE$infoWeighted) + 1)
marginalRelMLE
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
## MLE method -------------------------------
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
# add weights for each theta
itemParaInfoMLE$weights <- quadPoints$weights
# weighted information
itemParaInfoMLE$infoWeighted <- itemParaInfoMLE$weights * itemParaInfoMLE$x
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$infoWeighted)/(sum(itemParaInfoMLE$infoWeighted) + 1)
marginalRelMLE
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
## MLE method -------------------------------
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
# add weights for each theta
itemParaInfoMLE$weights <- quadPoints$weights
# weighted information
itemParaInfoMLE$infoWeighted <- itemParaInfoMLE$weights * itemParaInfoMLE$x
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$infoWeighted)/(sum(itemParaInfoMLE$infoWeighted) + 1)
marginalRelMLE
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
## MLE method -------------------------------
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
# add weights for each theta
itemParaInfoMLE$weights <- quadPoints$weights
# weighted information
itemParaInfoMLE$infoWeighted <- itemParaInfoMLE$weights * itemParaInfoMLE$x
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$infoWeighted)/(sum(itemParaInfoMLE$infoWeighted) + 1)
marginalRelMLE
MarginalRelMLE <- function(itemPara){
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
## MLE method -------------------------------
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
# add weights for each theta
itemParaInfoMLE$weights <- quadPoints$weights
# weighted information
itemParaInfoMLE$infoWeighted <- itemParaInfoMLE$weights * itemParaInfoMLE$x
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$infoWeighted)/(sum(itemParaInfoMLE$infoWeighted) + 1)
marginalRelMLE
}
MarginalRelMLE(itemPara)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
MarginalRelMLE <- function(itemPara){
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
## MLE method -------------------------------
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
# add weights for each theta
itemParaInfoMLE$weights <- quadPoints$weights
# weighted information
itemParaInfoMLE$infoWeighted <- itemParaInfoMLE$weights * itemParaInfoMLE$x
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$infoWeighted)/(sum(itemParaInfoMLE$infoWeighted) + 1)
marginalRelMLE
}
MarginalRelMLE(itemPara)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
View(itemParaRep)
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
## MLE method -------------------------------
# sum information by theta
itemParaInfoMLE <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfoMLE) <- c("theta", "infoSum")
# add weights for each theta
itemParaInfoMLE$weights <- quadPoints$weights
# weighted information
itemParaInfoMLE$infoWeighted <- itemParaInfoMLE$weights * itemParaInfoMLE$infoSum
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfoMLE$infoWeighted)/(sum(itemParaInfoMLE$infoWeighted) + 1)
marginalRelMLE
View(itemParaInfoMLE)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("theta", "infoSum")
# add weights for each theta
itemParaInfo$weights <- quadPoints$weights
View(itemParaInfo)
# weighted information
itemParaInfo$infoWeighted <- itemParaInfo$weights * itemParaInfo$infoSum
marginalRelMLE <- sum(itemParaInfo$infoWeighted)/(sum(itemParaInfo$infoWeighted) + 1)
marginalRelMLE
# inverse of information
itemParaInfo$infoSumInv <- 1 / (itemParaInfo$infoSum + 1) # cobtributed by population
View(itemParaInfo)
marginalRelEAP <- 1 - sum(itemParaInfo$infoSumInv * itemParaInfo$weights)
marginalRelEAP
### Marginal Reliability of IRT 2PL: MLE
library(statmod)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
MarginalRelMLE <- function(itemPara){
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("theta", "infoSum")
# add weights for each theta
itemParaInfo$weights <- quadPoints$weights
## MLE method
# weighted information
itemParaInfo$infoWeighted <- itemParaInfo$weights * itemParaInfo$infoSum
# marginal reliability MLE
marginalRelMLE <- sum(itemParaInfo$infoWeighted)/(sum(itemParaInfo$infoWeighted) + 1)
marginalRelMLE
}
MarginalRelMLE(itemPara)
### Marginal Reliability of IRT 2PL: EAP
library(statmod)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
MarginalRelMLE <- function(itemPara){
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("theta", "infoSum")
# add weights for each theta
itemParaInfo$weights <- quadPoints$weights
## EAP method
# inverse of information
itemParaInfo$infoSumInv <- 1 / (itemParaInfo$infoSum + 1) # cobtributed by population
marginalRelEAP <- 1 - sum(itemParaInfo$infoSumInv * itemParaInfo$weights)
marginalRelEAP
}
MarginalRelEAP(itemPara)
### Marginal Reliability of IRT 2PL: EAP
library(statmod)
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
MarginalRelEAP <- function(itemPara){
# transform item parameters to the logistic metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.701
# weights and nodes
quadPoints <- gauss.quad.prob(41, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(nrow(itemPara)), each = 41),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = 41*nrow(itemPara))
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.701 * a * (theta - b)))
Q = 1 - P
info = 1.701**2 * a**2 * P * Q
})
# sum information by theta
itemParaInfo <- aggregate(itemParaRep$info, by=list(Category=itemParaRep$theta), FUN=sum)
names(itemParaInfo) <- c("theta", "infoSum")
# add weights for each theta
itemParaInfo$weights <- quadPoints$weights
## EAP method
# inverse of information
itemParaInfo$infoSumInv <- 1 / (itemParaInfo$infoSum + 1) # cobtributed by population
marginalRelEAP <- 1 - sum(itemParaInfo$infoSumInv * itemParaInfo$weights)
marginalRelEAP
}
MarginalRelEAP(itemPara)
