itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
fxThetaTSS$SS <- rev(convTable$roundedSS)
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA,nrow = 41, ncol = 1)
for (i in 1:41){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41),42] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
View(cssemKolen)
# avarage CSSEM across theta distribution
errorVarKoen <- sum(cssemKolen^2 * quad_points$weights)
# avarage CSSEM across theta distribution
errorVarKoen <- sum(cssemKolen^2 * quadPoints$weights)
View(fxTheta)
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * fxThetaT$SS))
View(fxPrXi)
View(fxPrXi)
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi)
SSVarIRT <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi[,-42]))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarIRT
RelIRTSSKolen
meanSS <- sum(rev(SScon$Rounded.SS) * colSums(fx_prXi[,-42]))
SSVarIRT <- sum((rev(SScon$Rounded.SS) - meanSS)^2 * colSums(fx_prXi[,-42]))
# reliability
RelIRTSSKolen <- 1 - ErrorVarIRT / SSVarIRT
RelIRTSSKolen
}
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
# error variance: avarage CSSEM across theta distribution
errorVarKoen <- sum(cssemKolen^2 * quadPoints$weights)
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * fxThetaT$SS))
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
library(statmod)
library(classify)
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# number of quadrature
numOfQuad <- 41
# number of Items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- gauss.quad.prob(numOfQuad, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# reorder matrix by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
fxThetaTSS$SS <- rev(convTable$roundedSS)
# fx_CSSEM_IRT ---fxThetaT
# fx_CSSEM_IRT_new ------fxThetaTSS
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA,nrow = 41, ncol = 1)
for (i in 1:41){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41),42] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * fxThetaT$SS))
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
library(statmod)
library(classify)
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# number of quadrature
numOfQuad <- 41
# number of Items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- gauss.quad.prob(numOfQuad, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# reorder matrix by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
fxThetaTSS$SS <- rev(convTable$roundedSS)
# fx_CSSEM_IRT ---fxThetaT
# fx_CSSEM_IRT_new ------fxThetaTSS
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA,nrow = 41, ncol = 1)
for (i in 1:41){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41),42] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * fxThetaT$SS))
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
# variance of scale score
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
library(statmod)
library(classify)
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# number of quadrature
numOfQuad <- 41
# number of Items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- gauss.quad.prob(numOfQuad, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# reorder matrix by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
View(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
View(fxThetaT)
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
View(fxThetaTSS)
fxThetaTSS$SS <- rev(convTable$roundedSS)
colSums(fxThetaTSS)
# merge data
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA,nrow = 41, ncol = 1)
for (i in 1:41){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41),42] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
View(cssemKolen)
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * quadPoints$weights))
View(fxPrXi)
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
# variance of scale score
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
#' @title CSSEM Kolen's Method
#'
#' @description
#' A function to calculate CSEM for Scale Scores in IRT using Kolen's method
#'
#' @param numOfItem a numeric number indicating number of items
#' @param convTable a data frame or matrix containing conversion table of raw score to scale score
#'
#' @return a data frame containing CSSEM using Kolen's Method
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#'
#' @export
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
library(statmod)
library(classify)
CSSEMKolen <- function(itemPara, convTable){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# number of quadrature
numOfQuad <- 41
# number of Items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- gauss.quad.prob(numOfQuad, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# reorder matrix by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
fxThetaTSS$SS <- rev(convTable$roundedSS)
# merge data
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA,nrow = 41, ncol = 1)
for (i in 1:41){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41),42] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * quadPoints$weights))
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
# variance of scale score
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
}
CSSEMKolen(itemPara, convTable)
#' @title CSSEM Kolen's Method
#'
#' @description
#' A function to calculate CSEM for Scale Scores in IRT using Kolen's method
#'
#' @param numOfItem a numeric number indicating number of items
#' @param convTable a data frame or matrix containing conversion table of raw score to scale score
#'
#' @return a data frame containing CSSEM using Kolen's Method
#'
#' @author {Huan Liu, University of Iowa, \email{huan-liu-1@@uiowa.edu}}
#'
#' @export
# read item parameters from txt file
itemPara <- read.table("TestData/ItemParaFormX.txt")
# read conversion table
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
library(statmod)
library(classify)
CSSEMKolen <- function(itemPara, convTable){
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# number of quadrature
numOfQuad <- 41
# number of Items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- gauss.quad.prob(numOfQuad, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# reorder matrix by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
fxThetaTSS$SS <- rev(convTable$roundedSS)
# merge data
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA,nrow = 41, ncol = 1)
for (i in 1:41){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41),42] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * quadPoints$weights))
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
# variance of scale score
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
}
CSSEMKolen(itemPara, convTable)
convTable <- read.csv("TestData/ConversionTableFormX.csv")
convTable$roundedSS <- round(convTable$unroundedSS)
library(statmod)
library(classify)
# transform item parameters to the 1.702 metric
names(itemPara) <- c("b", "a")
itemPara[,"a"] <- itemPara[,"a"]/1.702
# number of quadrature
numOfQuad <- 41
# number of Items
numOfItem <- nrow(itemPara)
# weights and nodes
quadPoints <- gauss.quad.prob(numOfQuad, dist = "normal", mu = 0, sigma = 1)
# replicate item parameter and theta
itemParaRep <-itemPara[rep(seq_len(numOfItem), each = numOfQuad),]
itemParaRep$theta <- rep(quadPoints$nodes, each = 1, length.out = numOfQuad*numOfItem)
# calculate information by theta
itemParaRep <- within(itemParaRep, {
P = 0 + (1 - 0) / (1 + exp(-1.702 * a * (theta - b)))
Q = 1 - P
PQ = P * Q
info = 1.702**2 * a**2 * P * Q
})
# reorder matrix by theta
itemParaRep <- itemParaRep[order(itemParaRep$theta),]
# create matrix to store f(x|theta)
fxTheta <- matrix(NA, nrow = numOfQuad, ncol = numOfItem + 1)
# for loop to calculate fxTheta
for (i in 1:numOfQuad){
probs <- matrix(c(itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$P,
itemParaRep[(1 + numOfItem * (i - 1)):(numOfItem * i),]$Q),
nrow = numOfItem, ncol = 2, byrow = FALSE)
cats <- c(rep(2, numOfItem))
fxTheta[i, ] <- wlord(probs,cats)
}
# transform to data frame
fxTheta <- as.data.frame(fxTheta)
# transform data frame fxTheta
fxThetaT <- as.data.frame(t(fxTheta))
# reverse SS
fxThetaT$SS <- rev(convTable$roundedSS)
# true scale score
fxThetaTSS <- as.data.frame(apply(fxThetaT[c(1:41)], 2, function(x) x * fxThetaT$SS))
fxThetaTSS$SS <- rev(convTable$roundedSS)
# merge data
fxThetaTSS <- rbind(fxThetaT, colSums(fxThetaTSS))
# CSSEM condtional on theta
cssemKolen <- matrix(NA,nrow = 41, ncol = 1)
for (i in 1:41){
cssemKolen[i, 1] <- sqrt(sum((fxThetaTSS[c(1:41),42] - fxThetaTSS[42, i])^2 * fxThetaTSS[c(1:41),i]))
}
# error variance: avarage CSSEM across theta distribution
errorVarKolen <- sum(cssemKolen^2 * quadPoints$weights)
# variance of scale score
fxPrXi <- as.data.frame(apply(fxTheta[c(1:41)], 2, function(x) x * quadPoints$weights))
# mean of scale score
meanSS <- sum(rev(convTable$roundedSS) * colSums(fxPrXi))
# variance of scale score
SSVarKolen <- sum((rev(convTable$roundedSS) - meanSS)^2 * colSums(fxPrXi))
# reliability
RelIRTSSKolen <- 1 - errorVarKolen / SSVarKolen
RelIRTSSKolen
cssemKolen
plot(cssemKolen)
colSums(fxThetaTSS)
### Plot ---------------------------------
cssemKolen <- as.data.frame(cssemKolen)
### true scale score ---------
cssemKolen$TrueSS <- colSums(fxThetaTSS)[1:41]
View(cssemKolen)
names(cssemKolen) <- c("cssemKolen", "trueSS")
K <- ggplot(cssemKolen, aes(x = trueSS, y = cssemKolen)) +
geom_point(size = 2) +
scale_x_continuous(name = "True Scale Score", breaks  = seq(100,  130, 5)) +
scale_y_continuous(name = "CSSEM_Kolen IRT Method") +
theme_bw()
library(ggplot2)
ggplot(cssemKolen, aes(x = trueSS, y = cssemKolen)) +
geom_point(size = 2) +
scale_x_continuous(name = "True Scale Score", breaks  = seq(100,  130, 5)) +
scale_y_continuous(name = "CSSEM_Kolen IRT Method") +
theme_bw()
cssemKolen
write.csv(cssemKolen, "cssemKolen.csv")
